#!/usr/bin/perl
use strict;
use warnings;
use open qw( :std :encoding(UTF-8) );
use File::Basename qw(basename);
use XML::LibXML;
use Date::Format qw(time2str);
use Date::Parse qw(str2time);
use Digest::MD5;

sub writeScoreEntryFile($);
sub isEmptyUploadFile($);
sub extractScoreEntriesFromStats($);
sub extractScoreEntriesFromUpload($);
sub reduceScoreEntries(@);
sub calculateScoreEntryID($);
sub getMoreFullStepsNode($$);
sub getSingleChildByTagName($$);
sub convertStepsTypeToGame($);
sub formatAsUpload($$$$$);
sub formatAttributeStr(@);
sub formatHighScoreNode($);
sub formatScoreEntryPrettyName($);
sub cleanStr($);
sub assertPresent($@);
sub assertDateTime($$);
sub assertMd5sumMatches($$);
sub readFile($);
sub md5sum($);
sub mtime($);

my $SM_SAVE_DIR = "$ENV{HOME}/.stepmania/Save";
my $SM_STATS_XML_FILE = "$SM_SAVE_DIR/MachineProfile/Stats.xml";

my $BAK_DIR = "$ENV{HOME}/.local/share/stepmania-score-xml";
my $BAK_SCORES_DIR = "$BAK_DIR/scores";
my $BAK_STATS_DIR = "$BAK_DIR/stats";
my $BAK_UPLOAD_DIR = "$BAK_DIR/upload";
my $STATS_MACHINE_NAME_FILE = "$BAK_DIR/stats-machine-name";

my $MODE_BUILD_SCORES = "build-scores";
my $MODE_BACKUP_STATS = "backup-stats";

my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC [OPTS] --build-scores
    -parse scores from XML files
      -include upload files (included by default), unless --no-use-upload is given
        $BAK_UPLOAD_DIR/*.xml
      -include stats files (NOT included by default), only if --use-stats is given
        $BAK_STATS_DIR/*.xml
    -write all scores, one score per file, to
      $BAK_SCORES_DIR/

  $EXEC [OPTS] --backup-stats [BAK_NAME]
    -parse $SM_STATS_XML_FILE
    -get xml file MTIME
    -extract MIN_SCORE_DATE and MAX_SCORE_DATE
      -formatted YYYY-MM-DD, 0000-00-00 if no scores present
    -get MACHINE_NAME name from $STATS_MACHINE_NAME_FILE
    -copy to $BAK_STATS_DIR/<BAK_STATS_FILE>
      BAK_STATS_FILE
        if BAK_NAME given:
          stats_<MTIME>_<MACHINE_NAME>_<MIN_SCORE_DATE>_<MAX_SCORE_DATE>_<BAK_NAME>.xml
        otherwise:
          stats_<MTIME>_<MACHINE_NAME>_<MIN_SCORE_DATE>_<MAX_SCORE_DATE>.xml

  OPTS
    --use-upload
      include $BAK_UPLOAD_DIR/*.xml when building scores
      (this is the default)
    --no-use-upload
      do not include $BAK_UPLOAD_DIR/*.xml when building scores

    --use-stats
      include $BAK_STATS_DIR/*.xml when building scores
    --no-use-stats
      do not include $BAK_STATS_DIR/*.xml when building scores
      (this is the default)
";

sub main(@){
  my $mode = $MODE_BUILD_SCORES;
  my $statsBakName = undef;
  my $useUpload = 1;
  my $useStats = 0;
  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(--build-scores)$/){
      $mode = $MODE_BUILD_SCORES;
    }elsif($arg =~ /^(--backup-stats)$/){
      $mode = $MODE_BACKUP_STATS;
    }elsif($arg =~ /^(--use-upload)$/){
      $useUpload = 1;
    }elsif($arg =~ /^(--no-use-upload)$/){
      $useUpload = 0;
    }elsif($arg =~ /^(--use-stats)$/){
      $useStats = 1;
    }elsif($arg =~ /^(--no-use-stats)$/){
      $useStats = 0;
    }elsif($mode eq $MODE_BACKUP_STATS and not defined $statsBakName and $arg =~ /^\w+$/){
      $statsBakName = $arg;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  if($mode eq $MODE_BUILD_SCORES){
    my @scoreEntries;
    if($useUpload){
      for my $file(grep {-f $_} glob "$BAK_UPLOAD_DIR/*.xml"){
        @scoreEntries = (@scoreEntries, extractScoreEntriesFromUpload($file));
      }
    }

    if($useStats){
      for my $file(grep {-f $_} glob "$BAK_STATS_DIR/*.xml"){
        @scoreEntries = (@scoreEntries, extractScoreEntriesFromStats($file));
      }
    }

    @scoreEntries = reduceScoreEntries(@scoreEntries);

    for my $scoreEntry(@scoreEntries){
      writeScoreEntryFile($scoreEntry);
    }
  }elsif($mode eq $MODE_BACKUP_STATS){
    my $statsXmlFile = $SM_STATS_XML_FILE;

    my $mtime = mtime $statsXmlFile;

    my @scores = sort {$$a{epoch} <=> $$b{epoch}} extractScoreEntriesFromStats $statsXmlFile;
    my $minEpoch = @scores > 0 ? ${$scores[0]}{epoch} : undef;
    my $maxEpoch = @scores > 0 ? ${$scores[-1]}{epoch} : undef;
    my $minDate = defined $minEpoch ? time2str("%Y-%m-%d", $minEpoch) : "0000-00-00";
    my $maxDate = defined $maxEpoch ? time2str("%Y-%m-%d", $maxEpoch) : "0000-00-00";

    my $machineName = readFile $STATS_MACHINE_NAME_FILE;
    chomp $machineName;
    if($machineName !~ /^([a-z0-9_\-]+)$/){
      die "ERROR: invalid/missing MACHINE_NAME in $STATS_MACHINE_NAME_FILE\n";
    }

    my $fileName = "stats";
    $fileName .= "_${mtime}";
    $fileName .= "_${machineName}";
    $fileName .= "_${minDate}_${maxDate}";
    $fileName .= "_${statsBakName}" if defined $statsBakName;
    $fileName .= ".xml";

    my $destFile = "$BAK_STATS_DIR/$fileName";

    if(-e $destFile){
      assertMd5sumMatches($statsXmlFile, $destFile);
      print "skipping, already backed up to $destFile\n";
    }else{
      system "cp", "-a", $statsXmlFile, $destFile;
    }
  }else{
    die "ERROR: unknown mode $mode\n";
  }
}

sub writeScoreEntryFile($){
  my ($scoreEntry) = @_;
  my $xml = formatAsUpload($$scoreEntry{machineGuid}, $$scoreEntry{playerNum},
    $$scoreEntry{songNode}, $$scoreEntry{stepsNode}, $$scoreEntry{scoreNode});
  $xml =~ s/\n/\r\n/g;
  my $playerNum = $$scoreEntry{playerNum};

  my $epoch = $$scoreEntry{epoch};
  my $ymd = time2str("%Y-%m-%d", $epoch);

  my $outFile = "$BAK_SCORES_DIR/${ymd}_${epoch}_p${playerNum}_"
    . formatScoreEntryPrettyName($scoreEntry) . ".xml";
  open FH, "> $outFile" or die "ERROR: could not write $outFile\n$!\n";
  print FH $xml;
  close FH;
}

sub isEmptyUploadFile($){
  my ($uploadFile) = @_;
  my $contents = readFile($uploadFile);
  if($contents =~ /
    ^
    <\?xml.*\?>                             [\r\n]*
                                            [\r\n]*
    <Stats>                                 [\r\n]*
    <MachineGuid> [0-9a-f]+ <\/MachineGuid> [\r\n]*
    <RecentSongScores\/>                    [\r\n]*
    <\/Stats>                               [\r\n]*
    $
  /x){
    return 1;
  }else{
    return 0;
  }
}

sub extractScoreEntriesFromStats($){
  my ($statsFile) = @_;
  my @scoreEntries;

  my $dom = XML::LibXML->load_xml(location => $statsFile);

  my $machineGuid = $dom->findvalue("Stats/GeneralData/Guid");
  $machineGuid = "" if not $machineGuid;

  my $errorMsg = "ERROR: error in stats file $statsFile";

  for my $songNode($dom->findnodes("/Stats/SongScores/Song")){
    my $songDir = $songNode->getAttribute("Dir");
    assertPresent("$errorMsg - missing song dir", $songDir);
    for my $stepsNode($songNode->getChildrenByTagName("Steps")){
      my $smDiff = $stepsNode->getAttribute("Difficulty");
      my $stepsType = $stepsNode->getAttribute("StepsType");
      my @scoreNodes = $stepsNode->findnodes("HighScoreList/HighScore");

      assertPresent("$errorMsg [$songDir] - missing diff/game", $songDir, $smDiff);

      my $game = convertStepsTypeToGame($stepsType);
      for my $scoreNode(@scoreNodes){
        my $dateTimeXML = $scoreNode->findvalue("./DateTime");
        assertDateTime("$errorMsg [$songDir] invalid/missing DateTime", $dateTimeXML);
        my $epoch = str2time($dateTimeXML);
        my $percentDP = $scoreNode->findvalue("./PercentDP");

        push @scoreEntries, {
          songDir     => $songDir,
          game        => $game,
          smDiff      => $smDiff,
          machineGuid => $machineGuid,
          playerNum   => undef,
          epoch       => $epoch,
          percentDP   => $percentDP,

          songNode    => $songNode,
          stepsNode   => $stepsNode,
          scoreNode   => $scoreNode,
        };
      }
    }
  }

  if(@scoreEntries == 0){
    print STDERR "WARNING: no score entries found in stats file $statsFile\n";
  }

  return @scoreEntries;
}

sub extractScoreEntriesFromUpload($){
  my ($uploadFile) = @_;
  my @scoreEntries;

  my $dom = XML::LibXML->load_xml(location => $uploadFile);

  my $machineGuid = $dom->findvalue("Stats/MachineGuid");
  $machineGuid = "" if not $machineGuid;

  my $errorMsg = "ERROR: error in upload file $uploadFile";

  my @uploadFileContainerNodes = $dom->findnodes(
    "/Stats/RecentSongScores/HighScoreForASongAndSteps");
  for(my $i=0; $i<@uploadFileContainerNodes; $i++){
    my $containerNode = $uploadFileContainerNodes[$i];
    my $playerNum;
    if($i == 0 and @uploadFileContainerNodes == 1){
      $playerNum = 0; #only/center player
    }elsif($i == 0 and @uploadFileContainerNodes == 2){
      $playerNum = 1; #left player
    }elsif($i == 1 and @uploadFileContainerNodes == 2){
      $playerNum = 2; #right player
    }else{
      die "ERROR: more than two player scores in recent-scores file $uploadFile\n";
    }

    my $songNode = getSingleChildByTagName($containerNode, "Song");
    my $stepsNode = getSingleChildByTagName($containerNode, "Steps");
    my $scoreNode = getSingleChildByTagName($containerNode, "HighScore");
    assertPresent("$errorMsg - missing song/steps/score node", $songNode, $stepsNode, $scoreNode);

    my $songDir = $songNode->getAttribute("Dir");
    my $smDiff = $stepsNode->getAttribute("Difficulty");
    my $stepsType = $stepsNode->getAttribute("StepsType");
    my $dateTimeXML = $scoreNode->findvalue("./DateTime");
    my $percentDP = $scoreNode->findvalue("./PercentDP");

    assertPresent("$errorMsg - missing songDir/game/diff\n", $songDir, $smDiff, $stepsType);
    assertDateTime("$errorMsg - invalid/missing DateTime\n", $dateTimeXML);

    my $game = convertStepsTypeToGame($stepsType);
    my $epoch = str2time($dateTimeXML);

    push @scoreEntries, {
      songDir     => $songDir,
      game        => $game,
      smDiff      => $smDiff,
      machineGuid => $machineGuid,
      playerNum   => $playerNum,
      percentDP   => $percentDP,
      epoch       => $epoch,

      songNode    => $songNode,
      stepsNode   => $stepsNode,
      scoreNode   => $scoreNode,
    };
  }

  if(@scoreEntries == 0 and not isEmptyUploadFile($uploadFile)){
    die "ERROR: no score entries found in non-empty upload-file $uploadFile\n";
  }

  return @scoreEntries;
}

sub reduceScoreEntries(@){
  my @scoreEntries = @_;
  my $scoreEntriesByEpoch = {};
  for my $scoreEntry(@scoreEntries){
    my $epoch = $$scoreEntry{epoch};
    if(not defined $$scoreEntriesByEpoch{$epoch}){
      $$scoreEntriesByEpoch{$epoch} = [];
    }
    push @{$$scoreEntriesByEpoch{$epoch}}, $scoreEntry;
  }

  my @reducedScoreEntries;
  for my $epoch(sort keys %$scoreEntriesByEpoch){
    my @entries = @{$$scoreEntriesByEpoch{$epoch}};

    my @uniqScoreEntries;
    if(@entries == 1){
      #skip de-dupe/reduce for performance
      @uniqScoreEntries = @entries;
    }else{
      #calculate unique score IDs
      for my $entry(@entries){
        $$entry{id} = calculateScoreEntryID($entry);
      }

      #split dupes into buckets
      my @scoreIDGroups;
      while(@entries > 0){
        my $id = ${$entries[0]}{id};
        my @group = grep {$$_{id} eq $id} @entries;
        @entries = grep {$$_{id} ne $id} @entries;
        push @scoreIDGroups, [@group];
      }

      #de-dupe and combine
      for my $group(@scoreIDGroups){
        my $entry = shift @$group;

        #include the most full stepsNode from all the dupes
        for my $otherEntry(@$group){
          $$entry{stepsNode} = getMoreFullStepsNode($$entry{stepsNode}, $$otherEntry{stepsNode});
        }
        push @uniqScoreEntries, $entry;
      }
    }

    if(@uniqScoreEntries > 2){
      die "ERROR: more than two unique score entries for epoch=$epoch\n";
    }

    #ensure every score at this epoch is for the same song (different difficulty is fine)
    my $songDir = ${$uniqScoreEntries[0]}{songDir};
    for my $entry(@uniqScoreEntries){
      if($$entry{songDir} ne $songDir){
        die "ERROR: different simfiles for scores with the same epoch=$epoch\n";
      }
    }

    #assign player num
    for(my $i=0; $i<@uniqScoreEntries; $i++){
      my $entry = $uniqScoreEntries[$i];
      #p0 for only score, p1 for first score, p2 for second score
      my $playerNum = @uniqScoreEntries == 1 ? 0 : $i+1;
      if(defined $$entry{playerNum} and $$entry{playerNum} != $playerNum){
        die "ERROR: score epoch=$epoch is player#$$entry{playerNum}, expected p#$playerNum\n";
      }
      $$entry{playerNum} = $playerNum;
    }

    for my $entry(@uniqScoreEntries){
      push @reducedScoreEntries, $entry;
    }
  }

  return @reducedScoreEntries;
}

sub calculateScoreEntryID($){
  my ($scoreEntry) = @_;

  my @atts = qw(
    Grade
    PercentDP
    TapNoteScores/W1
    TapNoteScores/W2
    TapNoteScores/W3
    TapNoteScores/W4
    TapNoteScores/W5
    TapNoteScores/Miss
    TapNoteScores/AvoidMine
    TapNoteScores/HitMine
    HoldNoteScores/Held
    HoldNoteScores/LetGo
    HoldNoteScores/MissedHold
  );

  my $id = "";
  $id .= "$$scoreEntry{epoch}|";
  $id .= "$$scoreEntry{game}|";
  $id .= "$$scoreEntry{smDiff}|";
  for my $att(@atts){
    my $scoreVal = $$scoreEntry{scoreNode}->findvalue($att);
    $scoreVal = "" if not defined $scoreVal;
    if($scoreVal eq "" and $att =~ /HoldNoteScores\/MissedHold/){
      $scoreVal = 0; #some scores predate <MissedHold>, and were updated in stats but not upload
    }
    $id .= "$scoreVal|";
  }
  $id .= "$$scoreEntry{songDir}|";

  return $id;
}

sub getMoreFullStepsNode($$){
  my ($n1, $n2) = @_;
  my $desc1 = $n1->getAttribute("OnlineDescription");
  my $desc2 = $n2->getAttribute("OnlineDescription");
  my $ct1 = $n1->getAttribute("ChartType");
  my $ct2 = $n2->getAttribute("ChartType");

  $desc1 = "" if not defined $desc1;
  $desc2 = "" if not defined $desc2;
  $ct1 = "" if not defined $ct1;
  $ct2 = "" if not defined $ct2;

  my $len1 = length $n1->toString();
  my $len2 = length $n2->toString();

  if($desc1 ne "" and $desc2 eq ""){
    return $n1;
  }elsif($desc1 eq "" and $desc2 ne ""){
    return $n2;
  }elsif($ct1 ne "" and $ct2 eq ""){
    return $n1;
  }elsif($ct1 eq "" and $ct2 ne ""){
    return $n2;
  }elsif($len1 > $len2){
    return $n1;
  }elsif($len1 < $len2){
    return $n2;
  }else{
    return $n1;
  }
}

sub getSingleChildByTagName($$){
  my ($node, $tagName) = @_;
  my $nodeList = $node->getChildrenByTagName($tagName);
  if($nodeList->size() == 1){
    return $nodeList->get_node(1);
  }else{
    return undef;
  }
}

#dance-single           => singles
#StepsType_Dance_Single => singles
#dance-double           => doubles
#StepsType_Dance_Double => doubles
sub convertStepsTypeToGame($){
  my ($stepsType) = @_;
  my $game = $stepsType;
  $game =~ s/^StepsType[_\-]//i;
  $game =~ s/^dance[_\-]//i;
  $game =~ s/s$//; #singles/doubles => single/double, just in case
  if($game =~ /^single$/i){
    return "singles";
  }elsif($game =~ /^double$/i){
    return "doubles";
  }else{
    die "ERROR: unknown StepsType '$stepsType'\n";
  }
}

sub formatAsUpload($$$$$){
  my ($machineGuid, $playerNum, $songNode, $stepsNode, $scoreNode) = @_;

  my $highScoreXML = formatHighScoreNode($scoreNode);

  return ""
    . "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
    . "\n"
    . "<Stats>\n"
    . "<MachineGuid>$machineGuid</MachineGuid>\n"
    . "<RecentSongScores>\n"
    . "<HighScoreForASongAndSteps>\n"
    . "<Song" . formatAttributeStr($songNode->getAttributes()) . "/>\n"
    . "<Steps" . formatAttributeStr($stepsNode->getAttributes()) . "/>\n"
    . $highScoreXML
    . "</HighScoreForASongAndSteps>\n"
    . "</RecentSongScores>\n"
    . "</Stats>\n"
  ;
}

#use single-quotes for attributes
sub formatAttributeStr(@){
  my @atts = @_;
  my $str = "";
  for my $att(@atts){
    my $attName = $att->getName();
    my $attVal = $att->getValue();
    $attVal =~ s/&/&amp;/g;
    $attVal =~ s/'/&apos;/g;
    $attVal =~ s/"/&quot;/g;
    $attVal =~ s/</&lt;/g;
    $attVal =~ s/>/&gt;/g;
    $str .= " $attName='$attVal'";
  }
  return $str;
}

#expand all self-closed empty tags to match upload XML format
sub formatHighScoreNode($){
  my ($scoreNode) = @_;
  my $xml = $scoreNode->toString();
  $xml =~ s/^<(\w+)\/>$/<$1><\/$1>/gm;
  chomp $xml;
  $xml .= "\n";
  return $xml;
}

sub formatScoreEntryPrettyName($){
  my ($scoreEntry) = @_;
  my $songDir = $$scoreEntry{songDir};
  $songDir =~ s/^(\/?Songs\/)//i;
  my $game = $$scoreEntry{game};
  my $smDiff = $$scoreEntry{smDiff};

  return cleanStr($songDir) . "_" . cleanStr($game) . "_" . cleanStr($smDiff);
}

sub cleanStr($){
  my ($str) = @_;
  $str = lc $str;
  $str =~ s/'//g;
  $str =~ s/[^a-z0-9]+/-/g;
  $str =~ s/-+/-/g;
  $str =~ s/^-//;
  $str =~ s/-$//;
  return $str;
}

sub assertPresent($@){
  my ($msg, @elems) = @_;
  for my $elem(@elems){
    die $msg if not $elem;
  }
}
sub assertDateTime($$){
  my ($msg, $timeXML) = @_;
  if($timeXML !~ /^\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d$/){
    die $msg;
  }
}

sub assertMd5sumMatches($$){
  my ($f1, $f2) = @_;
  my $csum1 = md5sum $f1;
  my $csum2 = md5sum $f2;
  if(not defined $csum1 or not defined $csum2 or $csum1 ne $csum2){
    die "ERROR: checksum mismatch '$f1' vs '$f2'\n";
  }
}

sub readFile($){
  my ($file) = @_;
  open my $fh, "< $file" or die "ERROR: could not read $file\n$!\n";
  my $contents = join '', <$fh>;
  close $fh;
  return $contents;
}

sub md5sum($){
  my ($file) = @_;
  open my $fh, "< $file" or die "ERROR: could not read $file\n$!\n";
  my $md5sum = Digest::MD5->new->addfile($fh)->hexdigest;
  close $fh;
  die "ERROR: could not get md5sum of $file\n" if $md5sum !~ /^[0-9a-f]{32}$/;
  return $md5sum;
}

sub mtime($){
  my ($file) = @_;
  my @stat = stat $file;
  return $stat[9];
}

&main(@ARGV);
