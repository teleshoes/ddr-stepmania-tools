#!/usr/bin/perl
use strict;
use warnings;
use open qw( :std :encoding(UTF-8) );
use File::Basename qw(basename);
use XML::LibXML;
use Date::Format qw(time2str);
use Date::Parse qw(str2time);
use Digest::MD5;
use List::Util qw(sum);

sub buildStatsXML($$@);
sub buildStatsGeneralDataXml($$@);
sub wrapTag($$);
sub sumScoreAtt($@);
sub writeScoreEntryFile($);
sub isEmptyUploadFile($);
sub extractEpochFromScoresFile($);
sub extractEpochFromStatsFile($);
sub extractEpochFromUploadFile($);
sub extractCaloriesByDateFromStats($);
sub getScoreEntries($$$);
sub extractScoreEntriesFromStats($);
sub extractScoreEntriesFromUpload($);
sub extractScoreEntriesFromScore($);
sub reduceScoreEntries(@);
sub parseScoreDetails($);
sub calculateDancePoints($);
sub getScoreEntryID($);
sub getMoreFullStepsNode($$);
sub getSingleNode($$);
sub getSingleChildByTagName($$);
sub convertStepsTypeToGame($);
sub formatAsUpload($$$$$);
sub formatAttributeStr(@);
sub formatHighScoreNode($);
sub formatScoreEntryPrettyName($);
sub cleanStr($);
sub assertPresent($@);
sub assertDateTime($$);
sub assertMd5sumMatches($$);
sub readFile($);
sub md5sum($);
sub mtime($);
sub touch($$);

my $SM_SAVE_DIR = "$ENV{HOME}/.stepmania/Save";
my $SM_STATS_XML_FILE = "$SM_SAVE_DIR/MachineProfile/Stats.xml";

my $BAK_DIR = "$ENV{HOME}/.local/share/stepmania-score-xml";
my $BAK_SCORES_DIR = "$BAK_DIR/scores";
my $BAK_STATS_DIR = "$BAK_DIR/stats";
my $BAK_UPLOAD_DIR = "$BAK_DIR/upload";
my $STATS_MACHINE_NAME_FILE = "$BAK_DIR/stats-machine-name";

my $MODE_BUILD_SCORES = "build-scores";
my $MODE_BUILD_STATS = "build-stats";
my $MODE_BACKUP_STATS = "backup-stats";
my $MODE_RENAME_EMPTY_UPLOAD = "rename-empty-upload";
my $MODE_TOUCH_XML = "touch-xml";

my @SCORE_DETAILS_ATT_ARR = (
  grade               => "Grade",
  percentDP           => "PercentDP",
  surviveSeconds      => "SurviveSeconds",
  countW1             => "TapNoteScores/W1",
  countW2             => "TapNoteScores/W2",
  countW3             => "TapNoteScores/W3",
  countW4             => "TapNoteScores/W4",
  countW5             => "TapNoteScores/W5",
  countMiss           => "TapNoteScores/Miss",
  countAvoidMine      => "TapNoteScores/AvoidMine",
  countHitMine        => "TapNoteScores/HitMine",
  countHeld           => "HoldNoteScores/Held",
  countLetGo          => "HoldNoteScores/LetGo",
  countMissedHold     => "HoldNoteScores/MissedHold",
  radarTapsAndHolds   => "RadarValues/TapsAndHolds",
  radarJumps          => "RadarValues/Jumps",
  radarHolds          => "RadarValues/Holds",
  radarMines          => "RadarValues/Mines",
  radarHands          => "RadarValues/Hands",
  radarRolls          => "RadarValues/Rolls",
  radarLifts          => "RadarValues/Lifts",
  radarFakes          => "RadarValues/Fakes",
);
my @SCORE_DETAILS_ATT_NAMES = map {$SCORE_DETAILS_ATT_ARR[$_]}
                              grep {$_%2==0} 0..$#SCORE_DETAILS_ATT_ARR;
my %SCORE_DETAILS_ATT_PATHS_BY_NAME = @SCORE_DETAILS_ATT_ARR;

my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC [OPTS] --build-scores
    -parse scores from stepmania XML files
      -include upload files (included by default), unless --no-use-upload is given
        $BAK_UPLOAD_DIR/*.xml
      -include stats files (NOT included by default), only if --use-stats is given
        $BAK_STATS_DIR/*.xml
    -extract epoch from <DateTime> tag, and extract score details
    -remove duplicate scores
      -check for same epoch, PercentDP, simfile+game+difficulty, and tap/hold note counts
    -ensure that at most two unique scores exist for a given epoch
      -both scores must be for the same simfile
      -scores may have different difficulties
      -if only one score exists for an epoch:
        -assign player=p0
      -if two scores exist for an epoch:
        -assign the first encountered player=p1 and the second player=p2
    -write scores, one score per file, to
      $BAK_SCORES_DIR/
    -set mtime of score files to parsed epoch

  $EXEC [OPTS] --build-stats

  $EXEC [OPTS] --backup-stats [BAK_NAME]
    -parse $SM_STATS_XML_FILE
    -get xml file MTIME
    -extract MIN_SCORE_DATE and MAX_SCORE_DATE
      -formatted YYYY-MM-DD, 0000-00-00 if no scores present
    -get MACHINE_NAME name from $STATS_MACHINE_NAME_FILE
    -copy to $BAK_STATS_DIR/<BAK_STATS_FILE>
      BAK_STATS_FILE
        if BAK_NAME given:
          stats_<MTIME>_<MACHINE_NAME>_<MIN_SCORE_DATE>_<MAX_SCORE_DATE>_<BAK_NAME>.xml
        otherwise:
          stats_<MTIME>_<MACHINE_NAME>_<MIN_SCORE_DATE>_<MAX_SCORE_DATE>.xml
    -copy to $BAK_STATS_DIR/<BAK_STATS_MACHINE_SUMMARY_FILE>
      BAK_STATS_MACHINE_SUMMARY_FILE
        stats_<MACHINE_NAME>.xml
    -add a git commit if backup is new, unless --no-git is given:
      -run `git add <BAK_STATS_FILE> <BAK_STATS_MACHINE_SUMMARY_FILE>`
      -run `git commit -m 'automatic commit'

  $EXEC [OPTS] --rename-empty-upload
    -for each XML_FILE in $BAK_UPLOAD_DIR/*.xml
      -if XML_FILE contains no score information:
        -get <MTIME_EPOCH> of XML_FILE
        -rename XML_FILE => XML_FILE.empty.<MTIME_EPOCH>

  $EXEC [OPTS] --touch-xml
    -update mtime=EPOCH for $BAK_SCORES_DIR/*.xml
      -if filenanme matches: YYYY-MM-DD_<EPOCH>_*.xml
        -extract EPOCH from file
      -otherwise: FAIL immediately
    -update mtime=EPOCH for $BAK_STATS_DIR/*.xml
      -if filename matches stats_<EPOCH>_*.xml:
        -extract EPOCH from filename
      -otherwise:
        -list other stats XML files with identical contents
        -extract EPOCH from the first one that contains EPOCH
        -if no file with EPOCH is identical, FAIL immediately
    -update mtime=EPOCH for $BAK_UPLOAD_DIR/*.xml
      -if file is an empty upload file
        -if filename matches: *.empty.<EPOCH>.xml
          -extract EPOCH from file
        -otherwise: FAIL immediately
      -otherwise:
        -parse XML contents of file
        -extract '<DateTime>' tag from first score entry, convert to EPOCH
        -if no score entry exists, FAIL immediately

  OPTS
    --use-upload
      include $BAK_UPLOAD_DIR/*.xml when building scores
      (this is the default)
    --no-use-upload
      do not include $BAK_UPLOAD_DIR/*.xml when building scores

    --use-stats
      include $BAK_STATS_DIR/*.xml when building scores
    --no-use-stats
      do not include $BAK_STATS_DIR/*.xml when building scores
      (this is the default)

    --no-git
      never run `git add` or `git commit`
";

sub main(@){
  my $mode = $MODE_BUILD_SCORES;
  my $statsBakName = undef;
  my $useUpload = 1;
  my $useStats = 0;
  my $useGit = 1;
  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(--build-scores)$/){
      $mode = $MODE_BUILD_SCORES;
    }elsif($arg =~ /^(--build-stats)$/){
      $mode = $MODE_BUILD_STATS;
    }elsif($arg =~ /^(--backup-stats)$/){
      $mode = $MODE_BACKUP_STATS;
    }elsif($arg =~ /^(--rename-empty-upload)$/){
      $mode = $MODE_RENAME_EMPTY_UPLOAD;
    }elsif($arg =~ /^(--touch-xml)$/){
      $mode = $MODE_TOUCH_XML;
    }elsif($arg =~ /^(--use-upload)$/){
      $useUpload = 1;
    }elsif($arg =~ /^(--no-use-upload)$/){
      $useUpload = 0;
    }elsif($arg =~ /^(--use-stats)$/){
      $useStats = 1;
    }elsif($arg =~ /^(--no-use-stats)$/){
      $useStats = 0;
    }elsif($arg =~ /^(--no-git)$/){
      $useGit = 0;
    }elsif($mode eq $MODE_BACKUP_STATS and not defined $statsBakName and $arg =~ /^\w+$/){
      $statsBakName = $arg;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  if($mode eq $MODE_BUILD_SCORES){
    my @scoreEntries = getScoreEntries($useUpload, $useStats, 0);
    for my $scoreEntry(@scoreEntries){
      writeScoreEntryFile($scoreEntry);
    }
  }elsif($mode eq $MODE_BUILD_STATS){
    my $maxCalsByDate = {};
    for my $file(grep {-f $_} glob "$BAK_STATS_DIR/*.xml"){
      my $calsByDate = extractCaloriesByDateFromStats($file);
      for my $date(sort keys %$calsByDate){
        my $cals = $$calsByDate{$date};
        if(not defined $$maxCalsByDate{$date} or $$maxCalsByDate{$date} <= $cals){
          $$maxCalsByDate{$date} = $cals;
        }
      }
    }

    my $machineName = readFile $STATS_MACHINE_NAME_FILE;
    chomp $machineName;
    my $srcStatsFile = "$BAK_STATS_DIR/stats_$machineName.xml";
    if(not -e $srcStatsFile){
      die "ERROR: missing source stats file $srcStatsFile\n";
    }
    my @scoreEntries = getScoreEntries(0, 0, 1);

    my $xml = buildStatsXML($srcStatsFile, $maxCalsByDate, @scoreEntries);

  }elsif($mode eq $MODE_BACKUP_STATS){
    my $statsXmlFile = $SM_STATS_XML_FILE;

    my $mtime = mtime $statsXmlFile;

    my @scores = sort {$$a{epoch} <=> $$b{epoch}} extractScoreEntriesFromStats $statsXmlFile;
    my $minEpoch = @scores > 0 ? ${$scores[0]}{epoch} : undef;
    my $maxEpoch = @scores > 0 ? ${$scores[-1]}{epoch} : undef;
    my $minDate = defined $minEpoch ? time2str("%Y-%m-%d", $minEpoch) : "0000-00-00";
    my $maxDate = defined $maxEpoch ? time2str("%Y-%m-%d", $maxEpoch) : "0000-00-00";

    my $machineName = readFile $STATS_MACHINE_NAME_FILE;
    chomp $machineName;
    if($machineName !~ /^([a-z0-9_\-]+)$/){
      die "ERROR: invalid/missing MACHINE_NAME in $STATS_MACHINE_NAME_FILE\n";
    }

    my $fileName = "stats";
    $fileName .= "_${mtime}";
    $fileName .= "_${machineName}";
    $fileName .= "_${minDate}_${maxDate}";
    $fileName .= "_${statsBakName}" if defined $statsBakName;
    $fileName .= ".xml";

    my $destFile = "$BAK_STATS_DIR/$fileName";
    my $machineSummaryFile = "$BAK_STATS_DIR/stats_$machineName.xml";

    if(-e $destFile){
      assertMd5sumMatches($statsXmlFile, $destFile);
      print "skipping, already backed up to $destFile\n";
    }else{
      print "copying:\n";
      print "$statsXmlFile => $destFile\n";
      print "$statsXmlFile => $machineSummaryFile\n";
      system "cp", "-a", $statsXmlFile, $destFile;
      system "cp", "-a", $statsXmlFile, $machineSummaryFile;
      if($useGit){
        system "git", "-C", $BAK_STATS_DIR, "add", $destFile, $machineSummaryFile;
        system "git", "-C", $BAK_STATS_DIR, "commit", "-m", "automatic commit", "--date", "\@$mtime";
      }
    }
  }elsif($mode eq $MODE_RENAME_EMPTY_UPLOAD){
    for my $uploadFile(grep {-f $_} glob "$BAK_UPLOAD_DIR/*.xml"){
      if(isEmptyUploadFile($uploadFile)){
        if($uploadFile =~ /^.*\.empty\.\d+\.xml$/){
          print "skipping rename of empty $uploadFile\n";
        }else{
          my $epoch = mtime $uploadFile;
          my $destEmptyUploadFile = $uploadFile;
          $destEmptyUploadFile =~ s/\.xml$/.empty.$epoch.xml/;
          if(-e $destEmptyUploadFile){
            die "ERROR: $destEmptyUploadFile already exists\n";
          }
          print "renaming $uploadFile => $destEmptyUploadFile\n";
          system "mv", "--update=none", $uploadFile, $destEmptyUploadFile;
        }
      }
    }
  }elsif($mode eq $MODE_TOUCH_XML){
    my @allXmlFiles = grep {-f $_} (
      glob("$BAK_SCORES_DIR/*.xml"),
      glob("$BAK_STATS_DIR/*.xml"),
      glob("$BAK_UPLOAD_DIR/*.xml"),
    );
    for my $xmlFile(@allXmlFiles){
      my $epoch;
      if($xmlFile =~ /^$BAK_SCORES_DIR/){
        $epoch = extractEpochFromScoresFile($xmlFile);
      }elsif($xmlFile =~ /^$BAK_STATS_DIR/){
        $epoch = extractEpochFromStatsFile($xmlFile);
      }elsif($xmlFile =~ /^$BAK_UPLOAD_DIR/){
        $epoch = extractEpochFromUploadFile($xmlFile);
      }else{
        die "ERROR: could not categorize $xmlFile\n";
      }
      if(not defined $epoch or $epoch !~ /^\d+$/){
        die "ERROR: could not read epoch from $xmlFile\n";
      }
      my $mtime = mtime($xmlFile);
      if($mtime != $epoch){
        print "mtime: $xmlFile $mtime => $epoch\n";
        touch($xmlFile, $epoch);
      }
    }
  }else{
    die "ERROR: unknown mode $mode\n";
  }
}

sub buildStatsXML($$@){
  my ($srcStatsFile, $caloriesByDate, @scoreEntries) = @_;

  for my $scoreEntry(@scoreEntries){
    parseScoreDetails($scoreEntry);
  }

  my $dom = XML::LibXML->load_xml(location => $srcStatsFile);
  my $statsNode = getSingleNode($dom, "Stats");

  my $xml = ""
    . "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
    . "\n"
    . "<Stats>"
  ;

  for my $node($statsNode->childNodes()){
    my $tagName = $node->nodeName();
    if($tagName eq "GeneralData"){
      $xml .= buildStatsGeneralDataXML($node, $caloriesByDate, @scoreEntries);
    }else{
      $xml .= $node->toString();
    }
  }

  $xml .= "</Stats>\n";

  return $xml;
}

sub buildStatsGeneralDataXML($$@){
  my ($genDataNode, $caloriesByDate, @scoreEntries) = @_;
  my $xml = "";
  $xml .= "<GeneralData>";
  for my $node($genDataNode->childNodes()){
    my $tagName = $node->nodeName();
    if($tagName eq "TotalGameplaySeconds"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("surviveSeconds", @scoreEntries)));
    }elsif($tagName eq "TotalCaloriesBurned"){
      $xml .= wrapTag($tagName, sprintf("%.6f", sum(values %$caloriesByDate)));
    }elsif($tagName eq "TotalDancePoints"){
      $xml .= wrapTag($tagName, sum(map {calculateDancePoints($_)} @scoreEntries));
    }elsif($tagName eq "TotalTapsAndHolds"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("radarTapsAndHolds", @scoreEntries)));
    }elsif($tagName eq "TotalJumps"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("radarJumps", @scoreEntries)));
    }elsif($tagName eq "TotalHolds"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("radarHolds", @scoreEntries)));
    }elsif($tagName eq "TotalRolls"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("radarRolls", @scoreEntries)));
    }elsif($tagName eq "TotalMines"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("radarMines", @scoreEntries)));
    }elsif($tagName eq "TotalHands"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("radarHands", @scoreEntries)));
    }elsif($tagName eq "TotalLifts"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("radarLifts", @scoreEntries)));
    }elsif($tagName eq "NumSongsPlayedByPlayMode"){
      $xml .= ""
        . "<NumSongsPlayedByPlayMode>\n"
        .   wrapTag("Regular", 0+@scoreEntries) . "\n"
        . "</NumSongsPlayedByPlayMode>"
      ;
    }elsif($tagName eq "NumSongsPlayedByStyle"){
      $xml .= ""
        . "<NumSongsPlayedByStyle>\n"
        . "<Style Game='dance' Style='double'>"
        .   int(grep {$$_{game} eq "doubles"} @scoreEntries)
        . "</Style>\n"
        . "<Style Game='dance' Style='single'>"
        .   int(grep {$$_{game} eq "singles"} @scoreEntries)
        . "</Style>\n"
        . "</NumSongsPlayedByStyle>"
      ;
    }elsif($tagName eq "NumSongsPlayedByDifficulty"){
      $xml .= ""
        . "<NumSongsPlayedByDifficulty>\n"
        .   wrapTag("Beginner", int(grep {$$_{smDiff} eq "Beginner"} @scoreEntries)) . "\n"
        .   wrapTag("Easy", int(grep {$$_{smDiff} eq "Easy"} @scoreEntries)) . "\n"
        .   wrapTag("Medium", int(grep {$$_{smDiff} eq "Medium"} @scoreEntries)) . "\n"
        .   wrapTag("Hard", int(grep {$$_{smDiff} eq "Hard"} @scoreEntries)) . "\n"
        .   wrapTag("Challenge", int(grep {$$_{smDiff} eq "Challenge"} @scoreEntries)) . "\n"
        .   wrapTag("Edit", int(grep {$$_{smDiff} eq "Edit"} @scoreEntries)) . "\n"
        . "</NumSongsPlayedByDifficulty>"
      ;
    }elsif($tagName eq "NumTotalSongsPlayed"){
      $xml .= wrapTag($tagName, int(@scoreEntries));
    }else{
      $xml .= $node->toString();
    }
  }
  $xml .= "</GeneralData>";

  return $xml;
}

sub wrapTag($$){
  my ($tagName, $value) = @_;
  return "<$tagName>$value</$tagName>";
}

sub sumScoreAtt($@){
  my ($scoreDetailsAttName, @scoreEntries) = @_;
  return sum(map {$$_{scoreDetails}{$scoreDetailsAttName}} @scoreEntries);
}

sub writeScoreEntryFile($){
  my ($scoreEntry) = @_;
  my $xml = formatAsUpload($$scoreEntry{machineGuid}, $$scoreEntry{playerNum},
    $$scoreEntry{songNode}, $$scoreEntry{stepsNode}, $$scoreEntry{scoreNode});
  $xml =~ s/\n/\r\n/g;
  my $playerNum = $$scoreEntry{playerNum};

  my $epoch = $$scoreEntry{epoch};
  my $ymd = time2str("%Y-%m-%d", $epoch);

  my $outFile = "$BAK_SCORES_DIR/${ymd}_${epoch}_p${playerNum}_"
    . formatScoreEntryPrettyName($scoreEntry) . ".xml";
  open FH, "> $outFile" or die "ERROR: could not write $outFile\n$!\n";
  print FH $xml;
  close FH;

  touch($outFile, $epoch);
}

sub isEmptyUploadFile($){
  my ($uploadFile) = @_;
  my $contents = readFile($uploadFile);
  if($contents =~ /
    ^
    <\?xml.*\?>                             [\r\n]*
                                            [\r\n]*
    <Stats>                                 [\r\n]*
    <MachineGuid> [0-9a-f]+ <\/MachineGuid> [\r\n]*
    <RecentSongScores\/>                    [\r\n]*
    <\/Stats>                               [\r\n]*
    $
  /x){
    return 1;
  }else{
    return 0;
  }
}

sub extractEpochFromScoresFile($){
  my ($scoresFile) = @_;
  my $epoch;
  if($scoresFile =~ /^(?:.*\/)?\d\d\d\d-\d\d-\d\d_(\d+)_/){
    return $1;
  }
  return $epoch;
}

sub extractEpochFromStatsFile($){
  my ($statsFile) = @_;
  my $epoch;
  if($statsFile =~ /^(?:.*\/)?stats_(\d+)_/){
    $epoch = $1;
  }else{
    my $md5 = md5sum($statsFile);
    my @otherStatsFiles = grep {-f $_} glob "$BAK_STATS_DIR/*.xml";
    for my $otherStatsFile(@otherStatsFiles){
      my $otherMD5 = md5sum($otherStatsFile);
      if($md5 eq $otherMD5 and $otherStatsFile =~ /^(?:.*\/)?stats_(\d+)_/){
        $epoch = $1;
        last;
      }
    }
  }
  return $epoch;
}

sub extractEpochFromUploadFile($){
  my ($uploadFile) = @_;
  my $epoch;
  if(isEmptyUploadFile($uploadFile)){
    if($uploadFile =~ /\.empty\.(\d+)\.xml$/){
      $epoch = $1;
    }
  }else{
    my @scoreEntries = extractScoreEntriesFromUpload($uploadFile);
    if(@scoreEntries == 0){
      die "ERROR: could not read scores from non-empty upload file $uploadFile\n";
    }
    $epoch = ${$scoreEntries[0]}{epoch};
    for my $scoreEntry(@scoreEntries){
      if($epoch ne $$scoreEntry{epoch}){
        die "ERROR: mismatched <DateTime> in scores for $uploadFile\n";
      }
    }
  }
  return $epoch;
}

sub extractCaloriesByDateFromStats($){
  my ($statsFile) = @_;
  my $caloriesByDate = {};
  my $dom = XML::LibXML->load_xml(location => $statsFile);
  for my $cbNode($dom->findnodes("Stats/CalorieData/CaloriesBurned")){
    my $date = $cbNode->getAttribute("Date");
    my $cal = $cbNode->findvalue(".");
    if(defined $$caloriesByDate{$date}){
      die "ERROR: duplicate <CaloriesBurned> Date value $date in $statsFile\n";
    }
    $$caloriesByDate{$date} = $cal;
  }
  return $caloriesByDate;
}

sub getScoreEntries($$$){
  my ($useUpload, $useStats, $useScores) = @_;
  my @scoreEntries;
  if($useUpload){
    for my $file(grep {-f $_} glob "$BAK_UPLOAD_DIR/*.xml"){
      @scoreEntries = (@scoreEntries, extractScoreEntriesFromUpload($file));
    }
  }

  if($useStats){
    for my $file(grep {-f $_} glob "$BAK_STATS_DIR/*.xml"){
      @scoreEntries = (@scoreEntries, extractScoreEntriesFromStats($file));
    }
  }

  if($useScores){
    for my $file(grep {-f $_} glob "$BAK_SCORES_DIR/*.xml"){
      @scoreEntries = (@scoreEntries, extractScoreEntriesFromScore($file));
    }
  }
  @scoreEntries = reduceScoreEntries(@scoreEntries);

  return @scoreEntries;
}

sub extractScoreEntriesFromStats($){
  my ($statsFile) = @_;
  my @scoreEntries;

  my $dom = XML::LibXML->load_xml(location => $statsFile);

  my $machineGuid = $dom->findvalue("Stats/GeneralData/Guid");
  $machineGuid = "" if not $machineGuid;

  my $errorMsg = "ERROR: error in stats file $statsFile";

  for my $songNode($dom->findnodes("/Stats/SongScores/Song")){
    my $songDir = $songNode->getAttribute("Dir");
    assertPresent("$errorMsg - missing song dir", $songDir);
    for my $stepsNode($songNode->getChildrenByTagName("Steps")){
      my $smDiff = $stepsNode->getAttribute("Difficulty");
      my $stepsType = $stepsNode->getAttribute("StepsType");
      my @scoreNodes = $stepsNode->findnodes("HighScoreList/HighScore");

      assertPresent("$errorMsg [$songDir] - missing diff/game", $songDir, $smDiff);

      my $game = convertStepsTypeToGame($stepsType);
      for my $scoreNode(@scoreNodes){
        my $dateTimeXML = $scoreNode->findvalue("./DateTime");
        assertDateTime("$errorMsg [$songDir] invalid/missing DateTime", $dateTimeXML);
        my $epoch = str2time($dateTimeXML);
        my $percentDP = $scoreNode->findvalue("./PercentDP");

        push @scoreEntries, {
          songDir     => $songDir,
          game        => $game,
          smDiff      => $smDiff,
          machineGuid => $machineGuid,
          playerNum   => undef,
          epoch       => $epoch,
          percentDP   => $percentDP,

          songNode    => $songNode,
          stepsNode   => $stepsNode,
          scoreNode   => $scoreNode,
        };
      }
    }
  }

  if(@scoreEntries == 0){
    print STDERR "WARNING: no score entries found in stats file $statsFile\n";
  }

  return @scoreEntries;
}

sub extractScoreEntriesFromUpload($){
  my ($uploadFile) = @_;
  my @scoreEntries;

  my $dom = XML::LibXML->load_xml(location => $uploadFile);

  my $machineGuid = $dom->findvalue("Stats/MachineGuid");
  $machineGuid = "" if not $machineGuid;

  my $errorMsg = "ERROR: error in upload file $uploadFile";

  my @uploadFileContainerNodes = $dom->findnodes(
    "/Stats/RecentSongScores/HighScoreForASongAndSteps");
  for(my $i=0; $i<@uploadFileContainerNodes; $i++){
    my $containerNode = $uploadFileContainerNodes[$i];
    my $playerNum;
    if($i == 0 and @uploadFileContainerNodes == 1){
      $playerNum = 0; #only/center player
    }elsif($i == 0 and @uploadFileContainerNodes == 2){
      $playerNum = 1; #left player
    }elsif($i == 1 and @uploadFileContainerNodes == 2){
      $playerNum = 2; #right player
    }else{
      die "ERROR: more than two player scores in recent-scores file $uploadFile\n";
    }

    my $songNode = getSingleChildByTagName($containerNode, "Song");
    my $stepsNode = getSingleChildByTagName($containerNode, "Steps");
    my $scoreNode = getSingleChildByTagName($containerNode, "HighScore");
    assertPresent("$errorMsg - missing song/steps/score node", $songNode, $stepsNode, $scoreNode);

    my $songDir = $songNode->getAttribute("Dir");
    my $smDiff = $stepsNode->getAttribute("Difficulty");
    my $stepsType = $stepsNode->getAttribute("StepsType");
    my $dateTimeXML = $scoreNode->findvalue("./DateTime");
    my $percentDP = $scoreNode->findvalue("./PercentDP");

    assertPresent("$errorMsg - missing songDir/game/diff\n", $songDir, $smDiff, $stepsType);
    assertDateTime("$errorMsg - invalid/missing DateTime\n", $dateTimeXML);

    my $game = convertStepsTypeToGame($stepsType);
    my $epoch = str2time($dateTimeXML);

    push @scoreEntries, {
      songDir     => $songDir,
      game        => $game,
      smDiff      => $smDiff,
      machineGuid => $machineGuid,
      playerNum   => $playerNum,
      percentDP   => $percentDP,
      epoch       => $epoch,

      songNode    => $songNode,
      stepsNode   => $stepsNode,
      scoreNode   => $scoreNode,
    };
  }

  if(@scoreEntries == 0 and not isEmptyUploadFile($uploadFile)){
    die "ERROR: no score entries found in non-empty upload-file $uploadFile\n";
  }

  return @scoreEntries;
}

#same syntax as upload file, except one per file max
sub extractScoreEntriesFromScore($){
  my ($scoreFile) = @_;
  my @scoreEntries = extractScoreEntriesFromUpload($scoreFile);

  if(@scoreEntries != 1){
    die "ERROR: score file must contain exactly one score '$scoreFile'\n";
  }

  my $playerNumFromFilename;
  if($scoreFile =~ /_p([012])_/){
    $playerNumFromFilename = $1;
  }else{
    die "ERROR: could not parse PLAYER_NUM from $scoreFile\n";
  }

  for my $scoreEntry(@scoreEntries){
    $$scoreEntry{playerNum} = $playerNumFromFilename;
  }

  return @scoreEntries;
}

sub reduceScoreEntries(@){
  my @scoreEntries = @_;
  my $scoreEntriesByEpoch = {};
  for my $scoreEntry(@scoreEntries){
    my $epoch = $$scoreEntry{epoch};
    if(not defined $$scoreEntriesByEpoch{$epoch}){
      $$scoreEntriesByEpoch{$epoch} = [];
    }
    push @{$$scoreEntriesByEpoch{$epoch}}, $scoreEntry;
  }

  my @reducedScoreEntries;
  for my $epoch(sort keys %$scoreEntriesByEpoch){
    my @entries = @{$$scoreEntriesByEpoch{$epoch}};

    my @uniqScoreEntries;
    if(@entries == 1){
      #skip de-dupe/reduce for performance
      @uniqScoreEntries = @entries;
    }else{
      #calculate unique score IDs
      for my $entry(@entries){
        parseScoreDetails($entry); #parses XML
        $$entry{id} = getScoreEntryID($entry);
      }

      #split dupes into buckets
      my @scoreIDGroups;
      while(@entries > 0){
        my $id = ${$entries[0]}{id};
        my @group = grep {$$_{id} eq $id} @entries;
        @entries = grep {$$_{id} ne $id} @entries;
        push @scoreIDGroups, [@group];
      }

      #de-dupe and combine
      for my $group(@scoreIDGroups){
        my $entry = shift @$group;

        #include the most full stepsNode from all the dupes
        for my $otherEntry(@$group){
          $$entry{stepsNode} = getMoreFullStepsNode($$entry{stepsNode}, $$otherEntry{stepsNode});
        }
        push @uniqScoreEntries, $entry;
      }
    }

    if(@uniqScoreEntries > 2){
      die "ERROR: more than two unique score entries for epoch=$epoch\n";
    }

    #ensure every score at this epoch is for the same song (different difficulty is fine)
    my $songDir = ${$uniqScoreEntries[0]}{songDir};
    for my $entry(@uniqScoreEntries){
      if($$entry{songDir} ne $songDir){
        die "ERROR: different simfiles for scores with the same epoch=$epoch\n";
      }
    }

    #assign player num
    for(my $i=0; $i<@uniqScoreEntries; $i++){
      my $entry = $uniqScoreEntries[$i];
      #p0 for only score, p1 for first score, p2 for second score
      my $playerNum = @uniqScoreEntries == 1 ? 0 : $i+1;
      if(defined $$entry{playerNum} and $$entry{playerNum} != $playerNum){
        die "ERROR: score epoch=$epoch is player#$$entry{playerNum}, expected p#$playerNum\n";
      }
      $$entry{playerNum} = $playerNum;
    }

    for my $entry(@uniqScoreEntries){
      push @reducedScoreEntries, $entry;
    }
  }

  return @reducedScoreEntries;
}

sub parseScoreDetails($){
  my ($scoreEntry) = @_;

  if(defined $$scoreEntry{scoreDetails}){
    return;
  }

  my $details = {};

  for my $attName(@SCORE_DETAILS_ATT_NAMES){
    my $attPath = $SCORE_DETAILS_ATT_PATHS_BY_NAME{$attName};
    my $val = $$scoreEntry{scoreNode}->findvalue($attPath);
    $val = "" if not defined $val;
    $$details{$attName} = $val;
  }

  #fill in <MissedHold>=0 if <LetGo> is present and <MissedHold> is not
  #  some old scores predate <MissedHold>, and were updated in stats but not upload
  if($$details{countLetGo} =~ /\d+/ and $$details{countMissedHold} eq ""){
    $$details{countMissedHold} = 0;
  }

  $$scoreEntry{scoreDetails} = $details;
}

sub calculateDancePoints($){
  my ($scoreEntry) = @_;
  return 0
    + $$scoreEntry{scoreDetails}{countW1}      * 3
    + $$scoreEntry{scoreDetails}{countW2}      * 2
    + $$scoreEntry{scoreDetails}{countW3}      * 1
    + $$scoreEntry{scoreDetails}{countHeld}    * 3
    + $$scoreEntry{scoreDetails}{countHitMine} * -2
  ;
}

sub getScoreEntryID($){
  my ($scoreEntry) = @_;

  my $id = "";
  $id .= "$$scoreEntry{epoch}|";
  $id .= "$$scoreEntry{game}|";
  $id .= "$$scoreEntry{smDiff}|";

  if(not defined $$scoreEntry{scoreDetails}){
    die "ERROR: cannot get score entry ID before parsing score details\n";
  }

  for my $attName(@SCORE_DETAILS_ATT_NAMES){
    my $val = $$scoreEntry{scoreDetails}{$attName};
    $id .= "$val|";
  }
  $id .= "$$scoreEntry{songDir}|";

  return $id;
}

sub getMoreFullStepsNode($$){
  my ($n1, $n2) = @_;
  my $desc1 = $n1->getAttribute("OnlineDescription");
  my $desc2 = $n2->getAttribute("OnlineDescription");
  my $ct1 = $n1->getAttribute("ChartType");
  my $ct2 = $n2->getAttribute("ChartType");

  $desc1 = "" if not defined $desc1;
  $desc2 = "" if not defined $desc2;
  $ct1 = "" if not defined $ct1;
  $ct2 = "" if not defined $ct2;

  my $len1 = length $n1->toString();
  my $len2 = length $n2->toString();

  if($desc1 ne "" and $desc2 eq ""){
    return $n1;
  }elsif($desc1 eq "" and $desc2 ne ""){
    return $n2;
  }elsif($ct1 ne "" and $ct2 eq ""){
    return $n1;
  }elsif($ct1 eq "" and $ct2 ne ""){
    return $n2;
  }elsif($len1 > $len2){
    return $n1;
  }elsif($len1 < $len2){
    return $n2;
  }else{
    return $n1;
  }
}

sub getSingleNode($$){
  my ($node, $xpath) = @_;
  my $nodeList = $node->findnodes($xpath);
  if($nodeList->size() == 1){
    return $nodeList->get_node(1);
  }else{
    return undef;
  }
}

sub getSingleChildByTagName($$){
  my ($node, $tagName) = @_;
  my $nodeList = $node->getChildrenByTagName($tagName);
  if($nodeList->size() == 1){
    return $nodeList->get_node(1);
  }else{
    return undef;
  }
}

#dance-single           => singles
#StepsType_Dance_Single => singles
#dance-double           => doubles
#StepsType_Dance_Double => doubles
sub convertStepsTypeToGame($){
  my ($stepsType) = @_;
  my $game = $stepsType;
  $game =~ s/^StepsType[_\-]//i;
  $game =~ s/^dance[_\-]//i;
  $game =~ s/s$//; #singles/doubles => single/double, just in case
  if($game =~ /^single$/i){
    return "singles";
  }elsif($game =~ /^double$/i){
    return "doubles";
  }else{
    die "ERROR: unknown StepsType '$stepsType'\n";
  }
}

sub formatAsUpload($$$$$){
  my ($machineGuid, $playerNum, $songNode, $stepsNode, $scoreNode) = @_;

  my $highScoreXML = formatHighScoreNode($scoreNode);

  return ""
    . "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
    . "\n"
    . "<Stats>\n"
    . "<MachineGuid>$machineGuid</MachineGuid>\n"
    . "<RecentSongScores>\n"
    . "<HighScoreForASongAndSteps>\n"
    . "<Song" . formatAttributeStr($songNode->getAttributes()) . "/>\n"
    . "<Steps" . formatAttributeStr($stepsNode->getAttributes()) . "/>\n"
    . $highScoreXML
    . "</HighScoreForASongAndSteps>\n"
    . "</RecentSongScores>\n"
    . "</Stats>\n"
  ;
}

#use single-quotes for attributes
sub formatAttributeStr(@){
  my @atts = @_;
  my $str = "";
  for my $att(@atts){
    my $attName = $att->getName();
    my $attVal = $att->getValue();
    $attVal =~ s/&/&amp;/g;
    $attVal =~ s/'/&apos;/g;
    $attVal =~ s/"/&quot;/g;
    $attVal =~ s/</&lt;/g;
    $attVal =~ s/>/&gt;/g;
    $str .= " $attName='$attVal'";
  }
  return $str;
}

#expand all self-closed empty tags to match upload XML format
sub formatHighScoreNode($){
  my ($scoreNode) = @_;
  my $xml = $scoreNode->toString();
  $xml =~ s/^<(\w+)\/>$/<$1><\/$1>/gm;
  chomp $xml;
  $xml .= "\n";
  return $xml;
}

sub formatScoreEntryPrettyName($){
  my ($scoreEntry) = @_;
  my $songDir = $$scoreEntry{songDir};
  $songDir =~ s/^(\/?Songs\/)//i;
  my $game = $$scoreEntry{game};
  my $smDiff = $$scoreEntry{smDiff};

  return cleanStr($songDir) . "_" . cleanStr($game) . "_" . cleanStr($smDiff);
}

sub cleanStr($){
  my ($str) = @_;
  $str = lc $str;
  $str =~ s/'//g;
  $str =~ s/[^a-z0-9]+/-/g;
  $str =~ s/-+/-/g;
  $str =~ s/^-//;
  $str =~ s/-$//;
  return $str;
}

sub assertPresent($@){
  my ($msg, @elems) = @_;
  for my $elem(@elems){
    die $msg if not $elem;
  }
}
sub assertDateTime($$){
  my ($msg, $timeXML) = @_;
  if($timeXML !~ /^\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d$/){
    die $msg;
  }
}

sub assertMd5sumMatches($$){
  my ($f1, $f2) = @_;
  my $csum1 = md5sum $f1;
  my $csum2 = md5sum $f2;
  if(not defined $csum1 or not defined $csum2 or $csum1 ne $csum2){
    die "ERROR: checksum mismatch '$f1' vs '$f2'\n";
  }
}

sub readFile($){
  my ($file) = @_;
  open my $fh, "< $file" or die "ERROR: could not read $file\n$!\n";
  my $contents = join '', <$fh>;
  close $fh;
  return $contents;
}

sub md5sum($){
  my ($file) = @_;
  open my $fh, "< $file" or die "ERROR: could not read $file\n$!\n";
  my $md5sum = Digest::MD5->new->addfile($fh)->hexdigest;
  close $fh;
  die "ERROR: could not get md5sum of $file\n" if $md5sum !~ /^[0-9a-f]{32}$/;
  return $md5sum;
}

sub mtime($){
  my ($file) = @_;
  my @stat = stat $file;
  return $stat[9];
}

sub touch($$){
  my ($file, $epoch) = @_;
  utime($epoch, $epoch, $file);
}

&main(@ARGV);
