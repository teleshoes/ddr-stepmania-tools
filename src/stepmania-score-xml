#!/usr/bin/perl
use strict;
use warnings;
use Cwd qw(abs_path);
use File::Basename qw(dirname basename);
use lib dirname(abs_path($0));
use SMUtils::Utils qw(
  epochToYMDOrZero epochToYMD dtmStrToEpoch
  assertPresent assertDateTimeFmt assertMd5sumMatches
  md5sum mtime touch
);

use open qw( :std :encoding(UTF-8) );
use XML::LibXML;
use List::Util qw(max reduce sum);

sub buildStatsXML($$@);
sub buildStatsGeneralDataXml($$@);
sub buildStatsSongScoresXML(@);
sub buildStatsCalorieDataXML($);
sub wrapTag($$);
sub sumScoreAtt($@);
sub writeScoreEntryFile($);
sub isEmptyUploadFile($);
sub extractEpochFromScoresFile($);
sub extractEpochFromStatsFile($);
sub extractEpochFromUploadFile($);
sub extractCaloriesByDateFromStats($);
sub getScoreEntries($$$$);
sub extractScoreEntriesFromStats($);
sub extractScoreEntriesFromUpload($);
sub extractScoreEntriesFromScore($);
sub reduceScoreEntries(@);
sub parseScoreDetails($);
sub calculateDancePoints($);
sub getScoreEntryID($);
sub getSingleNode($$);
sub getSingleChildByTagName($$);
sub convertStepsTypeToGame($);
sub formatAsUpload($$$$$);
sub formatAttributeStr(@);
sub formatHighScoreNode($);
sub formatScoreEntryPrettyName($);
sub cleanStr($);
sub maxBy($@);
sub readFile($);
sub writeFile($$);

my $SM_SAVE_DIR = "$ENV{HOME}/.stepmania/Save";
my $SM_STATS_XML_FILE = "$SM_SAVE_DIR/MachineProfile/Stats.xml";

my $BAK_DIR = "$ENV{HOME}/.local/share/stepmania-score-xml";
my $BAK_SCORES_DIR = "$BAK_DIR/scores";
my $BAK_STATS_DIR = "$BAK_DIR/stats";
my $BAK_UPLOAD_DIR = "$BAK_DIR/upload";
my $STATS_MACHINE_NAME_FILE = "$BAK_DIR/stats-machine-name";

my $MODE_BUILD_SCORES = "build-scores";
my $MODE_BUILD_STATS = "build-stats";
my $MODE_BACKUP_STATS = "backup-stats";
my $MODE_RENAME_EMPTY_UPLOAD = "rename-empty-upload";
my $MODE_TOUCH_XML = "touch-xml";

my @SCORE_DETAILS_ATT_ARR = (
  grade               => "Grade",
  percentDP           => "PercentDP",
  surviveSeconds      => "SurviveSeconds",
  countW1             => "TapNoteScores/W1",
  countW2             => "TapNoteScores/W2",
  countW3             => "TapNoteScores/W3",
  countW4             => "TapNoteScores/W4",
  countW5             => "TapNoteScores/W5",
  countMiss           => "TapNoteScores/Miss",
  countAvoidMine      => "TapNoteScores/AvoidMine",
  countHitMine        => "TapNoteScores/HitMine",
  countHeld           => "HoldNoteScores/Held",
  countLetGo          => "HoldNoteScores/LetGo",
  countMissedHold     => "HoldNoteScores/MissedHold",
  radarTapsAndHolds   => "RadarValues/TapsAndHolds",
  radarJumps          => "RadarValues/Jumps",
  radarHolds          => "RadarValues/Holds",
  radarMines          => "RadarValues/Mines",
  radarHands          => "RadarValues/Hands",
  radarRolls          => "RadarValues/Rolls",
  radarLifts          => "RadarValues/Lifts",
  radarFakes          => "RadarValues/Fakes",
);
my @SCORE_DETAILS_ATT_NAMES = map {$SCORE_DETAILS_ATT_ARR[$_]}
                              grep {$_%2==0} 0..$#SCORE_DETAILS_ATT_ARR;
my %SCORE_DETAILS_ATT_PATHS_BY_NAME = @SCORE_DETAILS_ATT_ARR;

my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC [OPTS]
  $EXEC [OPTS] --build-scores
    -parse scores from stepmania XML files
      -include upload files (included by default), unless --no-use-upload is given
        $BAK_UPLOAD_DIR/*.xml
      -include stats files (NOT included by default), only if --use-stats is given
        $BAK_STATS_DIR/*.xml
    -if --skip-old is given:
      -skip any files older than the latest file in:
        $BAK_SCORES_DIR/*.xml
    -extract epoch from <DateTime> tag, and extract score details
    -remove duplicate scores
      -check for same epoch, PercentDP, simfile+game+difficulty, and tap/hold note counts
    -ensure that at most two unique scores exist for a given epoch
      -both scores must be for the same simfile
      -scores may have different difficulties
      -if only one score exists for an epoch:
        -assign player=p0
      -if two scores exist for an epoch:
        -assign the first encountered player=p1 and the second player=p2
    -write scores, one score per file, to
      $BAK_SCORES_DIR/
    -set mtime of score files to parsed epoch

  $EXEC [OPTS] --build-stats
    -re-parse scores from generated scores XML files
      $BAK_SCORES_DIR/*.xml
    -extract max <CaloriesBurned> by date from all <CalorieData> in stats XML files
      $BAK_STATS_DIR/*.xml
    -get MACHINE_NAME name from $STATS_MACHINE_NAME_FILE
    -find the CURRENT_MACHINE_STATS_XML file for the current MACHINE_NAME
      $BAK_STATS_DIR/stats_<MACHINE_NAME>.xml
    -generate new stats XML
      -copy <CURRENT_MACHINE_STATS_XML>
      -replace score+calorie statistic related elements in <GeneralData>
      -completely remove and replace <SongScores> element with parsed scores
      -remove and replace <CalorieData> element
    -write to $SM_STATS_XML_FILE.generated

  $EXEC [OPTS] --backup-stats [BAK_NAME]
    -parse $SM_STATS_XML_FILE
    -get xml file MTIME
    -extract MIN_SCORE_DATE and MAX_SCORE_DATE
      -formatted YYYY-MM-DD, 0000-00-00 if no scores present
    -get MACHINE_NAME name from $STATS_MACHINE_NAME_FILE
    -copy to $BAK_STATS_DIR/<BAK_STATS_FILE>
      BAK_STATS_FILE
        if BAK_NAME given:
          stats_<MTIME>_<MACHINE_NAME>_<MIN_SCORE_DATE>_<MAX_SCORE_DATE>_<BAK_NAME>.xml
        otherwise:
          stats_<MTIME>_<MACHINE_NAME>_<MIN_SCORE_DATE>_<MAX_SCORE_DATE>.xml
    -copy to $BAK_STATS_DIR/<BAK_STATS_MACHINE_SUMMARY_FILE>
      BAK_STATS_MACHINE_SUMMARY_FILE
        stats_<MACHINE_NAME>.xml
    -add a git commit if backup is new, unless --no-git is given:
      -run `git add <BAK_STATS_FILE> <BAK_STATS_MACHINE_SUMMARY_FILE>`
      -run `git commit -m 'automatic commit'

  $EXEC [OPTS] --rename-empty-upload
    -for each XML_FILE in $BAK_UPLOAD_DIR/*.xml
      -if XML_FILE contains no score information:
        -get <MTIME_EPOCH> of XML_FILE
        -rename XML_FILE => XML_FILE.empty.<MTIME_EPOCH>

  $EXEC [OPTS] --touch-xml
    -update mtime=EPOCH for $BAK_SCORES_DIR/*.xml
      -if filenanme matches: YYYY-MM-DD_<EPOCH>_*.xml
        -extract EPOCH from file
      -otherwise: FAIL immediately
    -update mtime=EPOCH for $BAK_STATS_DIR/*.xml
      -if filename matches stats_<EPOCH>_*.xml:
        -extract EPOCH from filename
      -otherwise:
        -list other stats XML files with identical contents
        -extract EPOCH from the first one that contains EPOCH
        -if no file with EPOCH is identical, FAIL immediately
    -update mtime=EPOCH for $BAK_UPLOAD_DIR/*.xml
      -if file is an empty upload file
        -if filename matches: *.empty.<EPOCH>.xml
          -extract EPOCH from file
        -otherwise: FAIL immediately
      -otherwise:
        -parse XML contents of file
        -extract '<DateTime>' tag from first score entry, convert to EPOCH
        -if no score entry exists, FAIL immediately

  OPTS
    --use-upload
      include $BAK_UPLOAD_DIR/*.xml when building scores
      (this is the default)
    --no-use-upload
      do not include $BAK_UPLOAD_DIR/*.xml when building scores

    --skip-old | --fast
      in --build-scores:
        skip parsing any XML input file older than the newest score in:
          $BAK_SCORES_DIR/*.xml
    --no-skip-old | --slow | --all
      do not skip any XML files in --build-scores

    --use-stats
      include $BAK_STATS_DIR/*.xml when building scores
    --no-use-stats
      do not include $BAK_STATS_DIR/*.xml when building scores
      (this is the default)

    --no-git
      never run `git add` or `git commit`
";

sub main(@){
  my $mode = $MODE_BUILD_SCORES;
  my $statsBakName = undef;
  my $useUpload = 1;
  my $useStats = 0;
  my $skipOld = 0;
  my $useGit = 1;
  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(--build-scores)$/){
      $mode = $MODE_BUILD_SCORES;
    }elsif($arg =~ /^(--build-stats)$/){
      $mode = $MODE_BUILD_STATS;
    }elsif($arg =~ /^(--backup-stats)$/){
      $mode = $MODE_BACKUP_STATS;
    }elsif($arg =~ /^(--rename-empty-upload)$/){
      $mode = $MODE_RENAME_EMPTY_UPLOAD;
    }elsif($arg =~ /^(--touch-xml)$/){
      $mode = $MODE_TOUCH_XML;
    }elsif($arg =~ /^(--use-upload)$/){
      $useUpload = 1;
    }elsif($arg =~ /^(--no-use-upload)$/){
      $useUpload = 0;
    }elsif($arg =~ /^(--use-stats)$/){
      $useStats = 1;
    }elsif($arg =~ /^(--no-use-stats)$/){
      $useStats = 0;
    }elsif($arg =~ /^(--skip-old|--fast)$/){
      $skipOld = 1;
    }elsif($arg =~ /^(--no-skip-old|--slow|--all)$/){
      $skipOld = 0;
    }elsif($arg =~ /^(--no-git)$/){
      $useGit = 0;
    }elsif($mode eq $MODE_BACKUP_STATS and not defined $statsBakName and $arg =~ /^\w+$/){
      $statsBakName = $arg;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  if($mode eq $MODE_BUILD_SCORES){
    my @scoreEntries = getScoreEntries($useUpload, $useStats, 0, $skipOld);
    for my $scoreEntry(@scoreEntries){
      writeScoreEntryFile($scoreEntry);
    }
  }elsif($mode eq $MODE_BUILD_STATS){
    my $maxCalsByDate = {};
    for my $file(grep {-f $_} glob "$BAK_STATS_DIR/*.xml"){
      my $calsByDate = extractCaloriesByDateFromStats($file);
      for my $date(sort keys %$calsByDate){
        my $cals = $$calsByDate{$date};
        if(not defined $$maxCalsByDate{$date} or $$maxCalsByDate{$date} <= $cals){
          $$maxCalsByDate{$date} = $cals;
        }
      }
    }

    my $machineName = readFile $STATS_MACHINE_NAME_FILE;
    chomp $machineName;
    my $srcStatsFile = "$BAK_STATS_DIR/stats_$machineName.xml";
    if(not -e $srcStatsFile){
      die "ERROR: missing source stats file $srcStatsFile\n";
    }

    my @scoreEntries = getScoreEntries(0, 0, 1, 0);

    my $xml = buildStatsXML($srcStatsFile, $maxCalsByDate, @scoreEntries);
    $xml =~ s/\n/\r\n/g;

    my $targetStatsFile = "$SM_STATS_XML_FILE.generated";
    print "writing $targetStatsFile\n";
    writeFile($targetStatsFile, $xml);
  }elsif($mode eq $MODE_BACKUP_STATS){
    my $statsXmlFile = $SM_STATS_XML_FILE;

    my $mtime = mtime $statsXmlFile;

    my @scores = sort {$$a{epoch} <=> $$b{epoch}} extractScoreEntriesFromStats $statsXmlFile;
    my $minEpoch = @scores > 0 ? ${$scores[0]}{epoch} : undef;
    my $maxEpoch = @scores > 0 ? ${$scores[-1]}{epoch} : undef;
    my $minDate = epochToYMDOrZero($minEpoch);
    my $maxDate = epochToYMDOrZero($maxEpoch);

    my $machineName = readFile $STATS_MACHINE_NAME_FILE;
    chomp $machineName;
    if($machineName !~ /^([a-z0-9_\-]+)$/){
      die "ERROR: invalid/missing MACHINE_NAME in $STATS_MACHINE_NAME_FILE\n";
    }

    my $fileName = "stats";
    $fileName .= "_${mtime}";
    $fileName .= "_${machineName}";
    $fileName .= "_${minDate}_${maxDate}";
    $fileName .= "_${statsBakName}" if defined $statsBakName;
    $fileName .= ".xml";

    my $destFile = "$BAK_STATS_DIR/$fileName";
    my $machineSummaryFile = "$BAK_STATS_DIR/stats_$machineName.xml";

    if(-e $destFile){
      assertMd5sumMatches($statsXmlFile, $destFile);
      print "skipping, already backed up to $destFile\n";
    }else{
      print "copying:\n";
      print "$statsXmlFile => $destFile\n";
      print "$statsXmlFile => $machineSummaryFile\n";
      system "cp", "-a", $statsXmlFile, $destFile;
      system "cp", "-a", $statsXmlFile, $machineSummaryFile;
      if($useGit){
        system "git", "-C", $BAK_STATS_DIR, "add", $destFile, $machineSummaryFile;
        system "git", "-C", $BAK_STATS_DIR, "commit", "-m", "automatic commit", "--date", "\@$mtime";
      }
    }
  }elsif($mode eq $MODE_RENAME_EMPTY_UPLOAD){
    for my $uploadFile(grep {-f $_} glob "$BAK_UPLOAD_DIR/*.xml"){
      if(isEmptyUploadFile($uploadFile)){
        if($uploadFile =~ /^.*\.empty\.\d+\.xml$/){
          print "skipping rename of empty $uploadFile\n";
        }else{
          my $epoch = mtime $uploadFile;
          my $destEmptyUploadFile = $uploadFile;
          $destEmptyUploadFile =~ s/\.xml$/.empty.$epoch.xml/;
          if(-e $destEmptyUploadFile){
            die "ERROR: $destEmptyUploadFile already exists\n";
          }
          print "renaming $uploadFile => $destEmptyUploadFile\n";
          system "mv", "--update=none", $uploadFile, $destEmptyUploadFile;
        }
      }
    }
  }elsif($mode eq $MODE_TOUCH_XML){
    my @allXmlFiles = grep {-f $_} (
      glob("$BAK_SCORES_DIR/*.xml"),
      glob("$BAK_STATS_DIR/*.xml"),
      glob("$BAK_UPLOAD_DIR/*.xml"),
    );
    for my $xmlFile(@allXmlFiles){
      my $epoch;
      if($xmlFile =~ /^$BAK_SCORES_DIR/){
        $epoch = extractEpochFromScoresFile($xmlFile);
      }elsif($xmlFile =~ /^$BAK_STATS_DIR/){
        $epoch = extractEpochFromStatsFile($xmlFile);
      }elsif($xmlFile =~ /^$BAK_UPLOAD_DIR/){
        $epoch = extractEpochFromUploadFile($xmlFile);
      }else{
        die "ERROR: could not categorize $xmlFile\n";
      }
      if(not defined $epoch or $epoch !~ /^\d+$/){
        die "ERROR: could not read epoch from $xmlFile\n";
      }
      my $mtime = mtime($xmlFile);
      if($mtime != $epoch){
        print "mtime: $xmlFile $mtime => $epoch\n";
        touch($xmlFile, $epoch);
      }
    }
  }else{
    die "ERROR: unknown mode $mode\n";
  }
}

sub buildStatsXML($$@){
  my ($srcStatsFile, $caloriesByDate, @scoreEntries) = @_;

  for my $scoreEntry(@scoreEntries){
    parseScoreDetails($scoreEntry);
  }

  my $dom = XML::LibXML->load_xml(location => $srcStatsFile);
  my $statsNode = getSingleNode($dom, "Stats");

  my $xml = ""
    . "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
    . "\n"
    . "<Stats>"
  ;

  for my $node($statsNode->childNodes()){
    my $tagName = $node->nodeName();
    if($tagName eq "GeneralData"){
      $xml .= buildStatsGeneralDataXML($node, $caloriesByDate, @scoreEntries);
    }elsif($tagName eq "SongScores"){
      $xml .= buildStatsSongScoresXML(@scoreEntries);
    }elsif($tagName eq "CalorieData"){
      $xml .= buildStatsCalorieDataXML($caloriesByDate);
    }else{
      $xml .= $node->toString();
    }
  }

  $xml .= "</Stats>\n";

  return $xml;
}

sub buildStatsGeneralDataXML($$@){
  my ($genDataNode, $caloriesByDate, @scoreEntries) = @_;
  my @passedEntries = grep{$$_{scoreDetails}{grade} !~ /fail/i} @scoreEntries;

  my %gradeCounts;
  for my $scoreEntry(@scoreEntries){
    my $grade = $$scoreEntry{scoreDetails}{grade};
    $gradeCounts{$grade} = 0 if not defined $gradeCounts{$grade};
    $gradeCounts{$grade}++;
  }

  my $xml = "";
  $xml .= "<GeneralData>";
  for my $node($genDataNode->childNodes()){
    my $tagName = $node->nodeName();
    if($tagName eq "TotalGameplaySeconds"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("surviveSeconds", @scoreEntries)));
    }elsif($tagName eq "TotalCaloriesBurned"){
      $xml .= wrapTag($tagName, sprintf("%.6f", sum(values %$caloriesByDate)));
    }elsif($tagName eq "TotalDancePoints"){
      $xml .= wrapTag($tagName, sum(map {calculateDancePoints($_)} @scoreEntries));
    }elsif($tagName eq "TotalTapsAndHolds"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("radarTapsAndHolds", @scoreEntries)));
    }elsif($tagName eq "TotalJumps"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("radarJumps", @scoreEntries)));
    }elsif($tagName eq "TotalHolds"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("radarHolds", @scoreEntries)));
    }elsif($tagName eq "TotalRolls"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("radarRolls", @scoreEntries)));
    }elsif($tagName eq "TotalMines"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("radarMines", @scoreEntries)));
    }elsif($tagName eq "TotalHands"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("radarHands", @scoreEntries)));
    }elsif($tagName eq "TotalLifts"){
      $xml .= wrapTag($tagName, int(sumScoreAtt("radarLifts", @scoreEntries)));
    }elsif($tagName eq "NumSongsPlayedByPlayMode"){
      $xml .= ""
        . "<NumSongsPlayedByPlayMode>\n"
        .   wrapTag("Regular", 0+@scoreEntries) . "\n"
        . "</NumSongsPlayedByPlayMode>"
      ;
    }elsif($tagName eq "NumSongsPlayedByStyle"){
      $xml .= ""
        . "<NumSongsPlayedByStyle>\n"
        . "<Style Game='dance' Style='double'>"
        .   int(grep {$$_{game} eq "doubles"} @scoreEntries)
        . "</Style>\n"
        . "<Style Game='dance' Style='single'>"
        .   int(grep {$$_{game} eq "singles"} @scoreEntries)
        . "</Style>\n"
        . "</NumSongsPlayedByStyle>"
      ;
    }elsif($tagName eq "NumSongsPlayedByDifficulty"){
      $xml .= ""
        . "<NumSongsPlayedByDifficulty>\n"
        .   wrapTag("Beginner", int(grep {$$_{smDiff} eq "Beginner"} @scoreEntries)) . "\n"
        .   wrapTag("Easy", int(grep {$$_{smDiff} eq "Easy"} @scoreEntries)) . "\n"
        .   wrapTag("Medium", int(grep {$$_{smDiff} eq "Medium"} @scoreEntries)) . "\n"
        .   wrapTag("Hard", int(grep {$$_{smDiff} eq "Hard"} @scoreEntries)) . "\n"
        .   wrapTag("Challenge", int(grep {$$_{smDiff} eq "Challenge"} @scoreEntries)) . "\n"
        .   wrapTag("Edit", int(grep {$$_{smDiff} eq "Edit"} @scoreEntries)) . "\n"
        . "</NumSongsPlayedByDifficulty>"
      ;
    }elsif($tagName eq "NumTotalSongsPlayed"){
      $xml .= wrapTag($tagName, int(@scoreEntries));
    }elsif($tagName eq "NumSongsPassedByPlayMode"){
      $xml .= ""
        . "<NumSongsPassedByPlayMode>\n"
        .   wrapTag("Regular", int(@passedEntries)) . "\n"
        . "</NumSongsPassedByPlayMode>"
      ;
    }elsif($tagName eq "NumStagesPassedByGrade"){
      $xml .= "<NumStagesPassedByGrade>\n";
      for my $grade(sort keys %gradeCounts){
        next if $grade =~ /fail/i;
        my $count = $gradeCounts{$grade};
        $xml .= wrapTag($grade, $count) . "\n";
      }
      $xml .= "</NumStagesPassedByGrade>";
    }else{
      my $xmlStr = $node->toString();
      if($tagName =~ /(DisplayName|CharacterID|LastUsedHighScoreName)$/){
        $xmlStr =~ s/^<$tagName\/>$/<$tagName><\/$tagName>/;
      }elsif($tagName eq "Song"){
        $xmlStr =~ s/Dir=""/Dir=''/;
      }
      $xml .= $xmlStr;
    }
  }
  $xml .= "</GeneralData>";

  return $xml;
}

sub buildStatsSongScoresXML(@){
  my @scoreEntries = @_;

  my $gameSortOrder = {
    singles => 1,
    doubles => 2,
  };
  my $smDiffSortOrder = {
    Beginner  => 1,
    Easy      => 2,
    Medium    => 3,
    Hard      => 4,
    Challenge => 5,
    Edit      => 6,
  };

  my $scoreEntriesBySongDir = {};
  for my $scoreEntry(@scoreEntries){
    my $songDir = $$scoreEntry{songDir};
    $$scoreEntriesBySongDir{$songDir} = [] if not defined $$scoreEntriesBySongDir{$songDir};
    push @{$$scoreEntriesBySongDir{$songDir}}, $scoreEntry;
  }

  my $xml = '';
  $xml .= "<SongScores>\n";

  my @songDirs = sort keys %$scoreEntriesBySongDir;

  for my $songDir(@songDirs){
    my @songScores = @{$$scoreEntriesBySongDir{$songDir}};
    my $firstSongScore = $songScores[0];

    $xml .= "<Song" . formatAttributeStr($$firstSongScore{songNode}->getAttributes()) . ">\n";

    my $scoresByGameByDiff = {};
    for my $scoreEntry(@songScores){
      my ($game, $smDiff) = ($$scoreEntry{game}, $$scoreEntry{smDiff});
      if(not defined $$scoresByGameByDiff{$game}){
        $$scoresByGameByDiff{$game} = {};
      }
      if(not defined $$scoresByGameByDiff{$game}{$smDiff}){
        $$scoresByGameByDiff{$game}{$smDiff} = [];
      }
      push @{$$scoresByGameByDiff{$game}{$smDiff}}, $scoreEntry;
    }

    my @games = sort {
      my $aOrder = $$gameSortOrder{$a};
      my $bOrder = $$gameSortOrder{$b};
      $aOrder = 0 if not defined $aOrder;
      $bOrder = 0 if not defined $bOrder;
      return $aOrder <=> $bOrder;
    } keys %$scoresByGameByDiff;

    for my $game(@games){
      my $gameStepsType = $game =~ /double/ ? "dance-double" : "dance-single";

      my @smDiffs = sort {
        my $aOrder = $$smDiffSortOrder{$a};
        my $bOrder = $$smDiffSortOrder{$b};
        $aOrder = 0 if not defined $aOrder;
        $bOrder = 0 if not defined $bOrder;
        return $aOrder <=> $bOrder;
      } keys %{$$scoresByGameByDiff{$game}};

      for my $smDiff(@smDiffs){
        my @stepScores = @{$$scoresByGameByDiff{$game}{$smDiff}};
        @stepScores = sort {
          $$b{percentDP} <=> $$a{percentDP}  #highest score first
          || $$b{epoch} <=> $$a{epoch}       #newest first as tie-breaker
        } @stepScores;

        my @passedStepScores = grep{$$_{scoreDetails}{grade} !~ /fail/i} @stepScores;

        my $latestScoreEntryByEpoch =
          maxBy(sub {${$_[0]}{epoch}}, @stepScores);
        my $maxAnyScoreEntryByPercentDP =
          maxBy(sub {${$_[0]}{scoreDetails}{percentDP}}, @stepScores);
        my $maxPassedScoreEntryByPercentDP =
          maxBy(sub {${$_[0]}{scoreDetails}{percentDP}}, @passedStepScores);

        my $lastPlayed = epochToYMD($$latestScoreEntryByEpoch{epoch});

        my $highScoreEntry = $maxPassedScoreEntryByPercentDP;
        $highScoreEntry = $maxAnyScoreEntryByPercentDP if not defined $highScoreEntry;

        my $highGrade = $$highScoreEntry{scoreDetails}{grade};

        $xml .= ""
          . "<Steps Difficulty='$smDiff' StepsType='$gameStepsType'>\n"
          . "<HighScoreList>\n"
          . "<NumTimesPlayed>" . (0+@stepScores) . "</NumTimesPlayed>\n"
          . "<LastPlayed>$lastPlayed</LastPlayed>\n"
          . "<HighGrade>$highGrade</HighGrade>\n"
        ;
        for my $scoreEntry(@stepScores){
          $xml .= formatHighScoreNode($$scoreEntry{scoreNode});
        }
        $xml .= ""
          . "</HighScoreList>\n"
          . "</Steps>\n"
        ;
      }
    }

    $xml .= ""
      . "</Song>\n"
    ;
  }

  $xml .= "</SongScores>";

  return $xml;
}

sub buildStatsCalorieDataXML($){
  my ($caloriesByDate) = @_;
  my $xml = "<CalorieData>\n";
  for my $date(sort keys %$caloriesByDate){
    my $cal = $$caloriesByDate{$date};
    $xml .= "<CaloriesBurned Date='$date'>$cal<\/CaloriesBurned>\n";
  }
  $xml .= "</CalorieData>";
  return $xml;
}

sub wrapTag($$){
  my ($tagName, $value) = @_;
  return "<$tagName>$value</$tagName>";
}

sub sumScoreAtt($@){
  my ($scoreDetailsAttName, @scoreEntries) = @_;
  return sum(map {$$_{scoreDetails}{$scoreDetailsAttName}} @scoreEntries);
}

sub writeScoreEntryFile($){
  my ($scoreEntry) = @_;
  my $xml = formatAsUpload($$scoreEntry{machineGuid}, $$scoreEntry{playerNum},
    $$scoreEntry{songNode}, $$scoreEntry{stepsNode}, $$scoreEntry{scoreNode});
  $xml =~ s/\n/\r\n/g;
  my $playerNum = $$scoreEntry{playerNum};

  my $epoch = $$scoreEntry{epoch};
  my $ymd = epochToYMD($epoch);

  my $outFile = "$BAK_SCORES_DIR/${ymd}_${epoch}_p${playerNum}_"
    . formatScoreEntryPrettyName($scoreEntry) . ".xml";
  writeFile($outFile, $xml);

  touch($outFile, $epoch);
}

sub isEmptyUploadFile($){
  my ($uploadFile) = @_;
  my $contents = readFile($uploadFile);
  if($contents =~ /
    ^
    <\?xml.*\?>                             [\r\n]*
                                            [\r\n]*
    <Stats>                                 [\r\n]*
    <MachineGuid> [0-9a-f]+ <\/MachineGuid> [\r\n]*
    <RecentSongScores\/>                    [\r\n]*
    <\/Stats>                               [\r\n]*
    $
  /x){
    return 1;
  }else{
    return 0;
  }
}

sub extractEpochFromScoresFile($){
  my ($scoresFile) = @_;
  my $epoch;
  if($scoresFile =~ /^(?:.*\/)?\d\d\d\d-\d\d-\d\d_(\d+)_/){
    return $1;
  }
  return $epoch;
}

sub extractEpochFromStatsFile($){
  my ($statsFile) = @_;
  my $epoch;
  if($statsFile =~ /^(?:.*\/)?stats_(\d+)_/){
    $epoch = $1;
  }else{
    my $md5 = md5sum($statsFile);
    my @otherStatsFiles = grep {-f $_} glob "$BAK_STATS_DIR/*.xml";
    for my $otherStatsFile(@otherStatsFiles){
      my $otherMD5 = md5sum($otherStatsFile);
      if($md5 eq $otherMD5 and $otherStatsFile =~ /^(?:.*\/)?stats_(\d+)_/){
        $epoch = $1;
        last;
      }
    }
  }
  return $epoch;
}

sub extractEpochFromUploadFile($){
  my ($uploadFile) = @_;
  my $epoch;
  if(isEmptyUploadFile($uploadFile)){
    if($uploadFile =~ /\.empty\.(\d+)\.xml$/){
      $epoch = $1;
    }
  }else{
    my @scoreEntries = extractScoreEntriesFromUpload($uploadFile);
    if(@scoreEntries == 0){
      die "ERROR: could not read scores from non-empty upload file $uploadFile\n";
    }
    $epoch = ${$scoreEntries[0]}{epoch};
    for my $scoreEntry(@scoreEntries){
      if($epoch ne $$scoreEntry{epoch}){
        die "ERROR: mismatched <DateTime> in scores for $uploadFile\n";
      }
    }
  }
  return $epoch;
}

sub extractCaloriesByDateFromStats($){
  my ($statsFile) = @_;
  my $caloriesByDate = {};
  my $dom = XML::LibXML->load_xml(location => $statsFile);
  for my $cbNode($dom->findnodes("Stats/CalorieData/CaloriesBurned")){
    my $date = $cbNode->getAttribute("Date");
    my $cal = $cbNode->findvalue(".");
    if(defined $$caloriesByDate{$date}){
      die "ERROR: duplicate <CaloriesBurned> Date value $date in $statsFile\n";
    }
    $$caloriesByDate{$date} = $cal;
  }
  return $caloriesByDate;
}

sub getScoreEntries($$$$){
  my ($useUpload, $useStats, $useScores, $skipOld) = @_;
  my @scoreEntries;

  my $maxMtime = undef;
  if($skipOld){
    $maxMtime = max(map {mtime($_)} glob "$BAK_SCORES_DIR/*.xml");
  }

  if($useUpload){
    for my $file(grep {-f $_} glob "$BAK_UPLOAD_DIR/*.xml"){
      next if defined $maxMtime and mtime($file) < $maxMtime;
      @scoreEntries = (@scoreEntries, extractScoreEntriesFromUpload($file));
    }
  }

  if($useStats){
    for my $file(grep {-f $_} glob "$BAK_STATS_DIR/*.xml"){
      next if defined $maxMtime and mtime($file) < $maxMtime;
      @scoreEntries = (@scoreEntries, extractScoreEntriesFromStats($file));
    }
  }

  if($useScores){
    for my $file(grep {-f $_} glob "$BAK_SCORES_DIR/*.xml"){
      next if defined $maxMtime and mtime($file) < $maxMtime;
      @scoreEntries = (@scoreEntries, extractScoreEntriesFromScore($file));
    }
  }
  @scoreEntries = reduceScoreEntries(@scoreEntries);

  return @scoreEntries;
}

sub extractScoreEntriesFromStats($){
  my ($statsFile) = @_;
  my @scoreEntries;

  my $dom = XML::LibXML->load_xml(location => $statsFile);

  my $machineGuid = $dom->findvalue("Stats/GeneralData/Guid");
  $machineGuid = "" if not $machineGuid;

  my $errorMsg = "ERROR: error in stats file $statsFile";

  for my $songNode($dom->findnodes("/Stats/SongScores/Song")){
    my $songDir = $songNode->getAttribute("Dir");
    assertPresent("$errorMsg - missing song dir", $songDir);
    for my $stepsNode($songNode->getChildrenByTagName("Steps")){
      my $smDiff = $stepsNode->getAttribute("Difficulty");
      my $stepsType = $stepsNode->getAttribute("StepsType");
      my @scoreNodes = $stepsNode->findnodes("HighScoreList/HighScore");

      assertPresent("$errorMsg [$songDir] - missing diff/game", $songDir, $smDiff);

      my $game = convertStepsTypeToGame($stepsType);
      for my $scoreNode(@scoreNodes){
        my $dateTimeXML = $scoreNode->findvalue("./DateTime");
        assertDateTimeFmt("$errorMsg [$songDir] invalid/missing DateTime", $dateTimeXML);
        my $epoch = dtmStrToEpoch($dateTimeXML);
        my $percentDP = $scoreNode->findvalue("./PercentDP");

        push @scoreEntries, {
          songDir     => $songDir,
          game        => $game,
          smDiff      => $smDiff,
          machineGuid => $machineGuid,
          playerNum   => undef,
          epoch       => $epoch,
          percentDP   => $percentDP,

          songNode    => $songNode,
          stepsNode   => $stepsNode,
          scoreNode   => $scoreNode,
        };
      }
    }
  }

  if(@scoreEntries == 0){
    print STDERR "WARNING: no score entries found in stats file $statsFile\n";
  }

  return @scoreEntries;
}

sub extractScoreEntriesFromUpload($){
  my ($uploadFile) = @_;
  my @scoreEntries;

  my $dom = XML::LibXML->load_xml(location => $uploadFile);

  my $machineGuid = $dom->findvalue("Stats/MachineGuid");
  $machineGuid = "" if not $machineGuid;

  my $errorMsg = "ERROR: error in upload file $uploadFile";

  my @uploadFileContainerNodes = $dom->findnodes(
    "/Stats/RecentSongScores/HighScoreForASongAndSteps");
  for(my $i=0; $i<@uploadFileContainerNodes; $i++){
    my $containerNode = $uploadFileContainerNodes[$i];
    my $playerNum;
    if($i == 0 and @uploadFileContainerNodes == 1){
      $playerNum = 0; #only/center player
    }elsif($i == 0 and @uploadFileContainerNodes == 2){
      $playerNum = 1; #left player
    }elsif($i == 1 and @uploadFileContainerNodes == 2){
      $playerNum = 2; #right player
    }else{
      die "ERROR: more than two player scores in recent-scores file $uploadFile\n";
    }

    my $songNode = getSingleChildByTagName($containerNode, "Song");
    my $stepsNode = getSingleChildByTagName($containerNode, "Steps");
    my $scoreNode = getSingleChildByTagName($containerNode, "HighScore");
    assertPresent("$errorMsg - missing song/steps/score node", $songNode, $stepsNode, $scoreNode);

    my $songDir = $songNode->getAttribute("Dir");
    my $smDiff = $stepsNode->getAttribute("Difficulty");
    my $stepsType = $stepsNode->getAttribute("StepsType");
    my $dateTimeXML = $scoreNode->findvalue("./DateTime");
    my $percentDP = $scoreNode->findvalue("./PercentDP");

    assertPresent("$errorMsg - missing songDir/game/diff\n", $songDir, $smDiff, $stepsType);
    assertDateTimeFmt("$errorMsg - invalid/missing DateTime\n", $dateTimeXML);

    my $game = convertStepsTypeToGame($stepsType);
    my $epoch = dtmStrToEpoch($dateTimeXML);

    push @scoreEntries, {
      songDir     => $songDir,
      game        => $game,
      smDiff      => $smDiff,
      machineGuid => $machineGuid,
      playerNum   => $playerNum,
      percentDP   => $percentDP,
      epoch       => $epoch,

      songNode    => $songNode,
      stepsNode   => $stepsNode,
      scoreNode   => $scoreNode,
    };
  }

  if(@scoreEntries == 0 and not isEmptyUploadFile($uploadFile)){
    die "ERROR: no score entries found in non-empty upload-file $uploadFile\n";
  }

  return @scoreEntries;
}

#same syntax as upload file, except one per file max
sub extractScoreEntriesFromScore($){
  my ($scoreFile) = @_;
  my @scoreEntries = extractScoreEntriesFromUpload($scoreFile);

  if(@scoreEntries != 1){
    die "ERROR: score file must contain exactly one score '$scoreFile'\n";
  }

  my $playerNumFromFilename;
  if($scoreFile =~ /_p([012])_/){
    $playerNumFromFilename = $1;
  }else{
    die "ERROR: could not parse PLAYER_NUM from $scoreFile\n";
  }

  for my $scoreEntry(@scoreEntries){
    $$scoreEntry{playerNum} = $playerNumFromFilename;
  }

  return @scoreEntries;
}

sub reduceScoreEntries(@){
  my @scoreEntries = @_;
  my $scoreEntriesByEpoch = {};
  for my $scoreEntry(@scoreEntries){
    my $epoch = $$scoreEntry{epoch};
    if(not defined $$scoreEntriesByEpoch{$epoch}){
      $$scoreEntriesByEpoch{$epoch} = [];
    }
    push @{$$scoreEntriesByEpoch{$epoch}}, $scoreEntry;
  }

  my @reducedScoreEntries;
  for my $epoch(sort keys %$scoreEntriesByEpoch){
    my @entries = @{$$scoreEntriesByEpoch{$epoch}};

    my @uniqScoreEntries;
    if(@entries == 1){
      #skip de-dupe/reduce for performance
      @uniqScoreEntries = @entries;
    }else{
      #calculate unique score IDs
      for my $entry(@entries){
        parseScoreDetails($entry); #parses XML
        $$entry{id} = getScoreEntryID($entry);
      }

      #split dupes into buckets
      my @scoreIDGroups;
      while(@entries > 0){
        my $id = ${$entries[0]}{id};
        my @group = grep {$$_{id} eq $id} @entries;
        @entries = grep {$$_{id} ne $id} @entries;
        push @scoreIDGroups, [@group];
      }

      #take the first score from each group as-is
      for my $group(@scoreIDGroups){
        my $entry = shift @$group;
        push @uniqScoreEntries, $entry;
      }
    }

    if(@uniqScoreEntries > 2){
      die "ERROR: more than two unique score entries for epoch=$epoch\n";
    }

    #ensure every score at this epoch is for the same song (different difficulty is fine)
    my $songDir = ${$uniqScoreEntries[0]}{songDir};
    for my $entry(@uniqScoreEntries){
      if($$entry{songDir} ne $songDir){
        die "ERROR: different simfiles for scores with the same epoch=$epoch\n";
      }
    }

    #assign player num
    for(my $i=0; $i<@uniqScoreEntries; $i++){
      my $entry = $uniqScoreEntries[$i];
      #p0 for only score, p1 for first score, p2 for second score
      my $playerNum = @uniqScoreEntries == 1 ? 0 : $i+1;
      if(defined $$entry{playerNum} and $$entry{playerNum} != $playerNum){
        die "ERROR: score epoch=$epoch is player#$$entry{playerNum}, expected p#$playerNum\n";
      }
      $$entry{playerNum} = $playerNum;
    }

    for my $entry(@uniqScoreEntries){
      push @reducedScoreEntries, $entry;
    }
  }

  return @reducedScoreEntries;
}

sub parseScoreDetails($){
  my ($scoreEntry) = @_;

  if(defined $$scoreEntry{scoreDetails}){
    return;
  }

  my $details = {};

  for my $attName(@SCORE_DETAILS_ATT_NAMES){
    my $attPath = $SCORE_DETAILS_ATT_PATHS_BY_NAME{$attName};
    my $val = $$scoreEntry{scoreNode}->findvalue($attPath);
    $val = "" if not defined $val;
    $$details{$attName} = $val;
  }

  #fill in <MissedHold>=0 if <LetGo> is present and <MissedHold> is not
  #  some old scores predate <MissedHold>, and were updated in stats but not upload
  if($$details{countLetGo} =~ /\d+/ and $$details{countMissedHold} eq ""){
    $$details{countMissedHold} = 0;
  }

  $$scoreEntry{scoreDetails} = $details;
}

sub calculateDancePoints($){
  my ($scoreEntry) = @_;
  return 0
    + $$scoreEntry{scoreDetails}{countW1}      * 3
    + $$scoreEntry{scoreDetails}{countW2}      * 2
    + $$scoreEntry{scoreDetails}{countW3}      * 1
    + $$scoreEntry{scoreDetails}{countHeld}    * 3
    + $$scoreEntry{scoreDetails}{countHitMine} * -2
  ;
}

sub getScoreEntryID($){
  my ($scoreEntry) = @_;

  my $id = "";
  $id .= "$$scoreEntry{epoch}|";
  $id .= "$$scoreEntry{game}|";
  $id .= "$$scoreEntry{smDiff}|";

  if(not defined $$scoreEntry{scoreDetails}){
    die "ERROR: cannot get score entry ID before parsing score details\n";
  }

  for my $attName(@SCORE_DETAILS_ATT_NAMES){
    my $val = $$scoreEntry{scoreDetails}{$attName};
    $id .= "$val|";
  }
  $id .= "$$scoreEntry{songDir}|";

  return $id;
}

sub getSingleNode($$){
  my ($node, $xpath) = @_;
  my $nodeList = $node->findnodes($xpath);
  if($nodeList->size() == 1){
    return $nodeList->get_node(1);
  }else{
    return undef;
  }
}

sub getSingleChildByTagName($$){
  my ($node, $tagName) = @_;
  my $nodeList = $node->getChildrenByTagName($tagName);
  if($nodeList->size() == 1){
    return $nodeList->get_node(1);
  }else{
    return undef;
  }
}

#dance-single           => singles
#StepsType_Dance_Single => singles
#dance-double           => doubles
#StepsType_Dance_Double => doubles
sub convertStepsTypeToGame($){
  my ($stepsType) = @_;
  my $game = $stepsType;
  $game =~ s/^StepsType[_\-]//i;
  $game =~ s/^dance[_\-]//i;
  $game =~ s/s$//; #singles/doubles => single/double, just in case
  if($game =~ /^single$/i){
    return "singles";
  }elsif($game =~ /^double$/i){
    return "doubles";
  }else{
    die "ERROR: unknown StepsType '$stepsType'\n";
  }
}

sub formatAsUpload($$$$$){
  my ($machineGuid, $playerNum, $songNode, $stepsNode, $scoreNode) = @_;

  my $highScoreXML = formatHighScoreNode($scoreNode);

  return ""
    . "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
    . "\n"
    . "<Stats>\n"
    . "<MachineGuid>$machineGuid</MachineGuid>\n"
    . "<RecentSongScores>\n"
    . "<HighScoreForASongAndSteps>\n"
    . "<Song" . formatAttributeStr($songNode->getAttributes()) . "/>\n"
    . "<Steps" . formatAttributeStr($stepsNode->getAttributes()) . "/>\n"
    . $highScoreXML
    . "</HighScoreForASongAndSteps>\n"
    . "</RecentSongScores>\n"
    . "</Stats>\n"
  ;
}

#use single-quotes for attributes
sub formatAttributeStr(@){
  my @atts = @_;
  my $str = "";
  for my $att(@atts){
    my $attName = $att->getName();
    my $attVal = $att->getValue();
    $attVal =~ s/&/&amp;/g;
    $attVal =~ s/'/&apos;/g;
    $attVal =~ s/"/&quot;/g;
    $attVal =~ s/</&lt;/g;
    $attVal =~ s/>/&gt;/g;
    $str .= " $attName='$attVal'";
  }
  return $str;
}

#expand all self-closed empty tags to match upload XML format
sub formatHighScoreNode($){
  my ($scoreNode) = @_;
  my $xml = $scoreNode->toString();
  $xml =~ s/^<(\w+)\/>$/<$1><\/$1>/gm;
  chomp $xml;
  $xml .= "\n";
  return $xml;
}

sub formatScoreEntryPrettyName($){
  my ($scoreEntry) = @_;
  my $songDir = $$scoreEntry{songDir};
  $songDir =~ s/^(\/?Songs\/)//i;
  my $game = $$scoreEntry{game};
  my $smDiff = $$scoreEntry{smDiff};

  return cleanStr($songDir) . "_" . cleanStr($game) . "_" . cleanStr($smDiff);
}

sub cleanStr($){
  my ($str) = @_;
  $str = lc $str;
  $str =~ s/'//g;
  $str =~ s/[^a-z0-9]+/-/g;
  $str =~ s/-+/-/g;
  $str =~ s/^-//;
  $str =~ s/-$//;
  return $str;
}

sub maxBy($@){
  my ($fct, @elems) = @_;
  return reduce(sub{&$fct($a) >= &$fct($b) ? $a : $b}, @elems);
}

sub readFile($){
  my ($file) = @_;
  open my $fh, "< $file" or die "ERROR: could not read $file\n$!\n";
  my $contents = join '', <$fh>;
  close $fh;
  return $contents;
}

sub writeFile($$){
  my ($file, $contents) = @_;
  open FH, "> $file" or die "ERROR: could not write $file\n$!\n";
  print FH $contents;
  close FH;
}

&main(@ARGV);
