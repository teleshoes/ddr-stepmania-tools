#!/usr/bin/perl
use strict;
use warnings;
#Copyright 2020 Elliot Wolk
#License: GPLv3

use IPC::Open2 qw(open2);
use File::Basename qw(dirname);
use Cwd qw(abs_path);

my $ROWS_PER_MEASURE = 192;
my $BEATS_PER_MEASURE = 4;
my $ROWS_PER_BEAT = int($ROWS_PER_MEASURE/$BEATS_PER_MEASURE); #48

my $CACHE_BASE_DIR_SUFFIX = ".cache/simfile-radar";

my $SM_CHARS = '[01234MLFAKNHGOETU]';

my @COMPRESSED_VARIABLE_NAMES = qw( NOTE_ROWS );

my @GAME_ABBREV_ARR = (
  ["dance-single"      => "singles"],
  ["dance-double"      => "doubles"],

  ["dance-solo"        => "ddrsolo"],
  ["dance-threepanel"  => "3-panel"],
  ["dance-couple-p1"   => "couple1"],
  ["dance-couple-p2"   => "couple2"],
  ["dance-routine-p1"  => "routin1"],
  ["dance-routine-p2"  => "routin2"],

  ["pump-single"       => "piu-sng"],
  ["pump-double"       => "piu-dbl"],
  ["pump-halfdouble"   => "piu-hdb"],

  ["pump-couple-p1"    => "piu-cp1"],
  ["pump-couple-p2"    => "piu-cp2"],

  ["gddm-new"          => "gddmnew"],
  ["gh-bass"           => "gh-bass"],
  ["gh-solo"           => "gh-solo"],
  ["guitar-five"       => "guitar5"],
  ["guitar-six"        => "guitar6"],
  ["pnm-five"          => "popnm-5"],
  ["pnm-four"          => "popnm-4"],
  ["pnm-nine"          => "popnm-9"],
  ["techno-single4"    => "tech-s4"],
  ["techno-single5"    => "tech-s5"],
  ["techno-single8"    => "tech-s8"],
  ["techno-single9"    => "tech-s9"],
  ["techno-double4"    => "tech-d4"],
  ["techno-double5"    => "tech-d5"],
  ["techno-double8"    => "tech-d8"],
  ["techno-double9"    => "tech-d9"],

  ["ez2-single"        => "ez2-sng"],
  ["ez2-double"        => "ez2-dbl"],
  ["ez2-real"          => "ez2-rel"],
  ["para-single"       => "parasng"],
  ["para-versus"       => "paravss"],
  ["ds3ddx-single"     => "ds3ddxs"],

  ["bm-single5"        => "bm-sng5"],
  ["bm-double5"        => "bm-dbl5"],
  ["bm-single7"        => "bm-sng7"],
  ["bm-double7"        => "bm-dbl7"],

  ["maniax-single"     => "dncmnxs"],
  ["maniax-double"     => "dncmnxd"],

  ["lights-cabinet"    => "lightsc"],
);
my @GAME_ABBREV_NAMES = map {$$_[0]} @GAME_ABBREV_ARR;
my %GAME_ABBREVS = map {$$_[0] => $$_[1]} @GAME_ABBREV_ARR;

my @DIFF_ABBREV_ARR = (
  ["beginner"  => "bEGNR"],
  ["basic"     => "BASIC"],
  ["difficult" => "DFCLT"],
  ["expert"    => "EXPRT"],
  ["challenge" => "CHLNG"],
);
my @DIFF_ABBREV_NAMES = map {$$_[0]} @DIFF_ABBREV_ARR;
my %DIFF_ABBREVS = map {$$_[0] => $$_[1]} @DIFF_ABBREV_ARR;

sub handleSimfile($$$$$$$$$);
sub formatStats($$$);
sub getSongRowCount($);
sub getSongDuration($$$);
sub getNoteCounts($);
sub getTotalFreezeRowCount($);
sub getMaxMeasureDensity($);
sub bpmToSecondsPerRow($);
sub removeWarps($$$);
sub calculateNotesPerSecondInfo($$$);
sub getTotalNoteIrregularity($);
sub getBPMChangeAmount($$);
sub formatDDRDiff($);
sub getNoteSetStats($$$$$);
sub isNoteSetStatsCached($$);
sub readNoteSetStatsCache($$);
sub writeNoteSetStatsCache($$$);
sub calculateNoteSetStats($$);
sub getSMInfo($$$$);
sub readSMInfoCache($$);
sub writeSMInfoCache($$);
sub songChecksum($$$);
sub parseSMFile($);
sub getUniqueDifficulties(@);
sub swapDupeDiffsForMissingAdjacentDiffs(@);
sub incrementDupeDiffs(@);
sub extractSongNameId($);
sub convertValuesByBeatToValuesByRow($);
sub generateGameDiffKey($$);
sub isGameDiffSkipped($$);
sub getExpandedNoteRows($);
sub abbrevGame($);
sub abbrevDiff($);
sub removeMiddleChar($);
sub formatTimeMSS($);
sub boingCompressString($);
sub boingDecompressString($);
sub pipeCmdData($$);
sub readFile($);
sub getChecksumStr($);
sub getChecksumFile($);
sub isExecAvailable($);

my $DEFAULT_MACHINE = "DDRA";

my $DEFAULT_FORMAT_SPEC = ""
  . ""     . "%-7s-GAME_ABBREV"
  . " | "  . "%-5s-DIFF_ABBREV"
  . " | "  . "S%03d-STREAM"
  . " "    . "V%03d-VOLTAGE"
  . " "    . "A%03d-AIR"
  . " "    . "F%03d-FREEZE"
  . " "    . "C%03d-CHAOS"
  . " | "  . "%-s-SONG_NAME_ID"
  . " |%n"
;
my $INFO_FORMAT_SPEC = ""
  . ""    . "%-7s-GAME_ABBREV"
  . " | " . "%-9s-DIFF_SM"
  . " | " . "%2d-SM_FEET"
  . " | " . "%4d-COUNT_TAPS taps"
  . " | " . "%4d-COUNT_HOLDS holds"
  . " | " . "%4d-COUNT_MINES mines"
  . " | " . "%4d-COUNT_ROLLS rolls"
  . " | " . "%4d-COUNT_JUMP_ROWS jumps"
  . " |%n"
;

my $usage = "Usage:
  $0 -h|--help
    show this message

  $0 [OPTS] SM_FILE [SM_FILE SM_FILE ..]
    analyze each SM_FILE (NOTES, BPMS, and STOPS),
      gather statistics for each VARIABLE below,
      and print the result using FORMAT_SPEC

    NOTE: groove radar values STREAM/VOLTAGE/AIR/FREEZE/CHAOS
          are calculated directly using the NOTES arrow patterns + BPMS + STOPS,
          NOT read from the simfile 'radar' attribute. as a result, the values
          may not exactly match any particular version of DDR, as the simfile may
          not exactly match DDR. in practice, they are within a point or two.
          Much of the numerical calculations were lifted from:
          https://dancedancerevolution.fandom.com/wiki/Groove_Radar

          the groove radar values that are hardcoded in the simfile are stored,
            as-is, in the variable SM_RADAR

      e.g.:
        > $0 GAIA.sm
        singles | beginner   | S22  | V22  | A12  | F8   | C0   |
        singles | basic      | S55  | V52  | A15  | F37  | C12  |
        singles | difficult  | S79  | V74  | A27  | F25  | C46  |
        singles | expert     | S122 | V109 | A0   | F0   | C108 |
        doubles | basic      | S55  | V52  | A24  | F37  | C12  |
        doubles | difficult  | S76  | V59  | A26  | F21  | C40  |
        doubles | expert     | S123 | V109 | A0   | F0   | C108 |

        > $0 --singles --expert --format=%07.2f-STREAM%n GAIA.sm
        0122.32


  VARIABLE
    GAME
      game type in simfile (e.g.: dance-single, dance-double, pump-single)
      EXCEPT:
        'dance-couple'  is split into 'dance-couple-p1'  and 'dance-couple-p2'
        'pump-couple'   is split into 'pump-couple-p1'   and 'pump-couple-p2'
        'dance-routine' is split into 'dance-routine-p1' and 'dance-routine-p2'
    DIFF_SM
      difficulty level in simfile (e.g.: Easy, Expert)
    DIFF
      same as DIFF, with DDR-like replacements when matched:
        Beginner  => beginner
        Easy      => basic
        Medium    => difficult
        Hard      => expert
        Expert    => challenge
        Challenge => challenge
      all other values are the same as DIFF_SM (e.g.: Edit, Fingers)
    GAME_ABBREV
      exactly 7-letter abbreviation of GAME
      for known game types:"
        . join('', map {
            sprintf("\n        %-16s => %7s", $_, $GAME_ABBREVS{$_})
          } @GAME_ABBREV_NAMES)
        . "
      otherwise:
        -if GAME contains exactly two sections separated by '-':
          -split into two sections: \"LEFT-RIGHT\" => <LEFT>, <RIGHT>
          -until the sum of the length of each section is <= 7 chars:
            -remove the middle character (rounded up) from one of the sections
              -shorten <RIGHT>  by 1 char unless it has <= 4 chars
              -shorten <LEFT>   by 1 char unless it has <= 3 chars
          -concatenate the sections (without '-'s): <GAME_ABBREV> = <LEFT><RIGHT>
        -if GAME contains exactly three sections separated by '-':
          -split into three sections: \"LEFT-MIDDLE-RIGHT\" => <LEFT>, <MIDDLE>, <RIGHT>
          -until the sum of the length of each section is <= 7 chars:
            -remove the middle character from one of the sections
              -shorten <RIGHT>  by 1 char unless it has <= 4 chars
              -shorten <MIDDLE> by 1 char unless it has <= 2 chars
              -shorten <LEFT>   by 1 char unless it has <= 1 chars
          -concatenate the sections (without '-'s): <GAME_ABBREV> = <LEFT><MIDDLE><RIGHT>
        -take the first 7 chars of <GAME_ABBREV>
        -append '_'s until <GAME_ABBREV> is exactly 7 chars
      e.g.:
        dance-12panelgame => dan12me
        a-bbbb-c          => abbbbc_
        daaance8          => daaance
    DIFF_ABBREV
      exactly 5-letter abbreviation of DIFF
      for known difficulties:"
        . join('', map {
            sprintf("\n        %-16s => %5s", $_, $DIFF_ABBREVS{$_})
          } @DIFF_ABBREV_NAMES)
        . "
      otherwise:
        -<DIFF_ABBREV> = lowercase <DIFF>
        -take the first 5 chars of <DIFF_ABBREV>
        -append '_'s until <DIFF_ABBREV> is exactly 5 chars
      e.g.:
        Edit    => edit_
        Fingers => finge
        Easy2   => easy2
    SONG_NAME
      parsed out of '#TITLE' in simfile
    SONG_NAME_TRANSLIT
      parsed out of '#TITLETRANLIST' if present, or '#TITLE' if not, in simfile
    SONG_NAME_ID
      song name ID, with lowercase-letters/numbers/hyphens only (e.g.: max-300)
      start with #TITLETRANSLIT (or #TITLE if no #TITLETRANLIST is present)
      invoke `zenius-ddrsonglist --extract-name-id TITLETRANSLIT`, if available
      if not or if output is malformed:
        lowercase TITLETRANLIST,
        perform some simple special replacements,
        replace all other invalid chars with '-',
        replace multiple '-'s with one '-',
        and trim leading/trailing '-'s
    SM_FEET
      parsed out of '#METER' (*.ssc) or '#NOTES' (*.sm) in simfile
      always a non-negative integer (or else ignored)
      presumably a DDR/ITG/PIU feet-meter/difficulty-rating, usually 1-20
    SM_RADAR
      parsed out of '#RADARVALUES' (*.ssc) or '#NOTES' (*.sm) in simfile
      this value is NOT interpreted, validated or used in any calculations,
      but is taken, as-is, from the simfile, if present
    SONG_DUR
      song duration, in fractional seconds
      this is calculated using BPM_ROWS, STOP_ROWS and SONG_ROW_COUNT
      e.g.: 121.000666666667
    SONG_DUR_FMT
      SONG_DUR formatted M:SS (e.g.: 2:01)
    NOTE_ROWS
      a comma-separated list of *expanded* note rows in one game+difficulty of the song
      there are $ROWS_PER_MEASURE rows for each measure
      each row is exactly 1/$ROWS_PER_BEAT of a beat ($BEATS_PER_MEASURE beats per measure)
        (note that there are no measure dividers or newlines. also, this value is very large)
      this list is expanded from the measure-separated rows in the simfile
        (the simfile has between 4 and $ROWS_PER_MEASURE rows per measure,
         which is expanded to exactly $ROWS_PER_MEASURE rows per measure)
      a single row is a list of characters (4 for singles, 5 for pump, 6 for solo, 8 for doubles)
      each character represents one arrow/panel, and is one of: $SM_CHARS
      these characters are used for calculations:
        0 - nothing for this arrow
        1 - a 'tap' arrow (regular arrow)
        2 - a 'hold' arrow (start hold)
        3 - hold/roll release (same character for 'hold' or 'roll')
        4 - a 'roll' arrow
        M - a 'mine' (note: shock rows are rows containing only 'mine')
      these are ignored:
        L - lift
        F - fake
        A - attack
        K - automatic keysound
        N - minefield (was never a real thing)
        H - hidden
        G - ???
        O - ???
        E - ???
        T - ???
        U - ???
    BPM_ROWS
      a comma-separated list of ROW=BPM pairs
      (this is converted from the BEAT=BPM pairs stored in the simfile)
        BEAT = fractional index of 1/4 note, as defined in the simfile
        BPM = beats per minute, as defined in the simfile
        ROW = BEAT*$ROWS_PER_BEAT
      e.g.: \"#BPMS:0=180,4=180,142=90,143=180,149=180,149.5=180,156=90,157=180;\"
            =>
            0=180,192=180,6816=90,6864=180,7152=180,7176=180,7488=90,7536=180
    STOP_ROWS
      a comma-separated list of ROW=STOP_DURATION pairs
      (this is converted from the BEAT=STOP_DURATION pairs stored in the simfile)
        BEAT = fractional index of 1/4 note, as defined in the simfile
        STOP_DURATION = stop duration in seconds, as defined in the simfile
        ROW = BEAT*$ROWS_PER_BEAT
      e.g.: \"#STOPS:149=0.167,149.5=0.167;\"
            =>
            7152=0.167,7176=0.167
    CHECKSUM
      checksum of the song arrow contents for one game/difficulty
        concatenate NOTE_ROWS, BPM_ROWS, and STOP_ROWS, with a % character between
        take the sha256sum of the result
    SONG_ROW_COUNT
      this is the total number of rows in NOTE_ROWS,
        with each row being 1/$ROWS_PER_MEASURE of a measure,
        and is equivalent to the number of beats in the song times $ROWS_PER_BEAT
      note that leading empty rows DO count towards the count or song duration,
        but trailing empty rows do NOT count towards the count or song duration
        (all empty rows at the end of a song are ignored)
      e.g.: 17281
    SONG_BEAT_COUNT
      SONG_ROW_COUNT divided by $ROWS_PER_BEAT, rounded to the nearest integer
      e.g.: 360
    MAX_MEASURE_DENSITY
      for every contiguous chain of $ROWS_PER_MEASURE rows in NOTE_ROWS,
        count the number of non-empty ROWS (not the number of arrows in those rows),
        where non-empty rows contain at least one arrow with a tap, hold, roll, or mine
      take the maximum count of non-empty rows of any contiguous chain
      if NOTE_ROWS has fewer than $ROWS_PER_MEASURE rows (song is shorter than one measure),
        count the total number of non-empty rows
    MAX_NOTE_ROWS_PER_SEC
      slice note rows into (roughly) 1-second segments,
        allowing segments to overlap,
        and select the segment with the most note rows
      (roughly 1.0s, means max-note-rows-per-sec may be fractional)
        -only consider at segments of AT MOST one second
        -only consider segments that start on a note
          (i.e.: this results in a MINIMUM of note-rows-per=second = 1)
        -never consider segments that are ENTIRELY part of another segment
          (i.e.: only consider the longest possible segment, as close to 1.0s as possible)
    TOTAL_FREEZE_ROW_COUNT
      find every hold-row, count the number of rows until its released, and sum the counts
        a hold-row is a row with a single-arrow-hold-start or a multi-arrow-hold-start
        a hold-row is released when ALL of its arrows have a hold-release
          i.e.: the last hold-release for all the arrows in the hold-start
      note:
        holds on different arrows that start at different times can overlap,
          and each is counted independently
        multi-arrow holds only count once, and the longest-held arrow is used
    TOTAL_NOTE_IRREGULARITY
      sum( ARROW_COUNT * TIMING_IRREGULARITY / INTERVAL_MEASURES ) for each row in NOTE_ROWS
      an arbitrary measure of how closely packed notes with weird timings are
        (this is one of two components of CHAOS, along with BPM_CHANGE_AMOUNT)
        this value typically ranges from 0 to 6000
      for each row in NOTE_ROWS:
        find the ARROW_COUNT, the number of taps/holds/rolls/mines in the row
          e.g.: 0 for empty row (contributes nothing to the total)
                1 for single-arrow taps/holds/rolls/mines
                2 for regular two-arrow jumps
                4 for shocks/all-mines on singles play
                8 for shocks/all-mines on doubles play
        find the TIMING_IRREGULARITY, based on the timing of the row within a measure
          (sometimes called 'arrow color', as some noteskins assign different colors)
          timings have arbitrarily-defined TIMING_IRREGULARITY values:
            1/4 notes (red arrows)     => 0
            1/8 notes (blue arrows)    => 0.5
            1/16 notes (yellow arrows) => 1
            everything else            => 1.25
          note that this is counted the same for taps, holds, rolls, and mines/shocks,
            regardless of what 'arrow color' the noteskin uses for these
        find the INTERVAL_MEASURES, in fractional measures,
          between this note-row and the previous note-row
          (count the number of rows between, and divide by $ROWS_PER_MEASURE)
        divide the arbitrary timing-irregularity based on
          the timing of each note within a measure (arrow color),
          by the fractional number of measures between that note and the previous note,
          and multiply by the ARROW_COUNT
      finally, take the sum for each row
    BPM_CHANGE_AMOUNT
      sum( BPM_CHANGE_DIFF )
      the sum of the amount that BPMs change in a song
        (this is one of two components of CHAOS, along with TOTAL_NOTE_IRREGULARITY)
      the absolute value of the difference between the old BPM and the new BPM,
        for each change AND stop, all added together
        this does NOT count the first BPM
          (a song with one fixed BPM and no stops has a BPM_CHANGE_AMOUNT of 0)
        a stop is equivalent to a change from 0 BPM back to the current BPM,
          though NOT the current BPM to 0 BPM, which is ignored
          (a stop counts only once, not twice, and the length of the stop is ignored)
        a stop and a BPM change on the same row (1/$ROWS_PER_MEASURE of a measure)
          counts only as a change from 0BPM to the new BPM
          (i.e.: stop+change counts only once)
      e.g.:
        BPM=100, BPM=300, BPM=100           => BPM_CHANGE_AMOUNT=400
        BPM=100, stop, stop, stop           => BPM_CHANGE_AMOUNT=300
        BPM=100, BPM=300, stop, BPM=100     => BPM_CHANGE_AMOUNT=700
        BPM=50, stop&BPM=100, stop, BPM=120 => BPM_CHANGE_AMOUNT=170
    COUNT_NOTE_ROWS
      total number of rows in NOTE_ROWS that contain:
        single-arrow-tap,        multi-arrow-tap,
        single-arrow-hold-start, multi-arrow-hold-start,
        single-arrow-roll-start, multi-arrow-roll-start
      e.g.: '0001', '1100', '0002', '0202', '0400', '4400'
    COUNT_TAP_ROWS
      total number of rows in NOTE_ROWS that contain:
        single-arrow-tap,        multi-arrow-tap
      e.g.: '0001', '1100'
    COUNT_HOLD_ROWS
      total number of rows in NOTE_ROWS that contain:
        single-arrow-hold-start, multi-arrow-hold-start
      e.g.: '0002', '0202'
    COUNT_ROLL_ROWS
      total number of rows in NOTE_ROWS that contain:
        single-arrow-roll-start, multi-arrow-roll-start
      e.g.: '0400', '4400'
    COUNT_JUMP_ROWS
      total number of rows in NOTE_ROWS that contain:
        mutli-arrow-tap,
        multi-arrow-hold-start
        multi-arrow-roll-start
      e.g.: '1100', '0202', '4400'
    COUNT_MINE_ROWS
      total number of rows in NOTE_ROWS that contain:
        single-mine,              multi-mine
      e.g.: '0M00', 'MM00'
    COUNT_SHOCK_ROWS
      total number of rows in NOTE_ROWS that contain ONLY mines, for all arrows
        (no 'empty' arrows, no taps, etc)
      e.g.: 'MMMM'
    COUNT_TAPS
      total number of tap ARROWS in all rows in NOTE_ROWS
        e.g.: a row with a jump ('1100') increases COUNT_TAPS by 2, and COUNT_TAP_ROWS by 1
    COUNT_HOLDS
      total number of hold ARROWS in all rows in NOTE_ROWS
        e.g.: a row with a jump-hold ('0202') increases COUNT_HOLDS by 2, and COUNT_HOLD_ROWS by 1
    COUNT_ROLLS
      total number of roll ARROWS in all rows in NOTE_ROWS
        e.g.: a row with a jump-roll ('4400') increases COUNT_ROLLS by 2, and COUNT_ROLL_ROWS by 1
    COUNT_MINES
      total number of MINES in all rows in NOTE_ROWS
        e.g.: a row with 3 mines ('0MMM') increases COUNT_MINES by 3, and COUNT_MINE_ROWS by 1

    TOTAL_NOTES                = COUNT_NOTE_ROWS + COUNT_SHOCK_ROWS
    TOTAL_JUMPS_SHOCKS         = COUNT_JUMP_ROWS + COUNT_SHOCK_ROWS
    NOTES_PER_MIN              = 60 * TOTAL_NOTES / SONG_DUR
    AVG_BPM                    = 60 * (SONG_ROW_COUNT/$ROWS_PER_BEAT) / SONG_DUR
    MAX_DENSITY_PER_MIN        = AVG_BPM * (MAX_MEASURE_DENSITY/4)
    JUMPS_SHOCKS_PER_MIN       = 60 * TOTAL_JUMPS_SHOCKS / SONG_DUR
    FREEZE_BEAT_COUNT          = TOTAL_FREEZE_ROW_COUNT/$ROWS_PER_BEAT
    FREEZE_RATIO_10K           = 10000 * FREEZE_BEAT_COUNT / SONG_BEAT_COUNT
    BPM_CHANGE_AMOUNT_PER_MIN  = 60 * BPM_CHANGE_AMOUNT / SONG_DUR
    OVERALL_IRREGULARITY       = TOTAL_NOTE_IRREGULARITY * (1 + (BPM_CHANGE_AMOUNT_PER_MIN/1500))
    IRREG_PER_CENTISECOND      = 100 * OVERALL_IRREGULARITY / SONG_DUR

    STREAM_DDRA    (singles, NOTES_PER_MIN >= 300) = (NOTES_PER_MIN-139)*100/161
    STREAM_DDRA    (doubles, NOTES_PER_MIN >= 300) = (NOTES_PER_MIN-183)*100/117
    STREAM_DDRA    (any,     NOTES_PER_MIN < 300 ) = NOTES_PER_MIN/3
    STREAM_DDRSN2  (singles, NOTES_PER_MIN >= 300) = (NOTES_PER_MIN-203)*100/97
    STREAM_DDRSN2  (doubles, NOTES_PER_MIN >= 300) = (NOTES_PER_MIN-205)*20/19
    STREAM_DDRSN2  (any,     NOTES_PER_MIN < 300 ) = NOTES_PER_MIN/3

    VOLTAGE_DDRA    (any, MAX_DENSITY_PER_MIN >= 600) = (MAX_DENSITY_PER_MIN+594)*100/1194
    VOLTAGE_DDRA    (any, MAX_DENSITY_PER_MIN < 600 ) = MAX_DENSITY_PER_MIN/6
    VOLTAGE_DDRSN2  (any, MAX_DENSITY_PER_MIN >= 600) = (MAX_DENSITY_PER_MIN+102)*100/702
    VOLTAGE_DDRSN2  (any, MAX_DENSITY_PER_MIN < 600 ) = MAX_DENSITY_PER_MIN/6

    AIR_DDRA    (singles, JUMPS_SHOCKS_PER_MIN >= 55) = (JUMPS_SHOCKS_PER_MIN+36)*100/91
    AIR_DDRA    (doubles, JUMPS_SHOCKS_PER_MIN >= 55) = (JUMPS_SHOCKS_PER_MIN+35)*10/9
    AIR_DDRA    (any,     JUMPS_SHOCKS_PER_MIN < 55 ) = JUMPS_SHOCKS_PER_MIN*20/11
    AIR_DDRSN2  (any,     JUMPS_SHOCKS_PER_MIN >= 55) = (JUMPS_SHOCKS_PER_MIN-1)*50/27
    AIR_DDRSN2  (any,     JUMPS_SHOCKS_PER_MIN < 55 ) = JUMPS_SHOCKS_PER_MIN*20/11

    FREEZE_DDRA    (singles, FREEZE_RATIO_10K >= 3500) = (FREEZE_RATIO_10K+2484)*100/5984
    FREEZE_DDRA    (doubles, FREEZE_RATIO_10K >= 3500) = (FREEZE_RATIO_10K+2246)*100/5746
    FREEZE_DDRA    (any,     FREEZE_RATIO_10K < 3500 ) = FREEZE_RATIO_10K/35
    FREEZE_DDRSN2  (singles, FREEZE_RATIO_10K >= 3500) = (FREEZE_RATIO_10K+2484)*100/5984
    FREEZE_DDRSN2  (doubles, FREEZE_RATIO_10K >= 3500) = (FREEZE_RATIO_10K+2246)*100/5746
    FREEZE_DDRSN2  (any,     FREEZE_RATIO_10K < 3500 ) = FREEZE_RATIO_10K/35

    CHAOS_DDRA    (singles, IRREG_PER_CENTISECOND >= 2000) = (IRREG_PER_CENTISECOND+21605)*100/23605
    CHAOS_DDRA    (doubles, IRREG_PER_CENTISECOND >= 2000) = (IRREG_PER_CENTISECOND+16628)*100/18629
    CHAOS_DDRA    (any,     IRREG_PER_CENTISECOND < 2000 ) = IRREG_PER_CENTISECOND/20
    CHAOS_DDRSN2  (singles, IRREG_PER_CENTISECOND >= 2000) = (IRREG_PER_CENTISECOND+21605)*100/23605
    CHAOS_DDRSN2  (doubles, IRREG_PER_CENTISECOND >= 2000) = (IRREG_PER_CENTISECOND+16628)*100/18628
    CHAOS_DDRSN2  (any,     IRREG_PER_CENTISECOND < 2000 ) = IRREG_PER_CENTISECOND/20

    STREAM  = STREAM_<MACHINE> (default MACHINE is $DEFAULT_MACHINE)
    VOLTAGE = VOLTAGE_<MACHINE> (default MACHINE is $DEFAULT_MACHINE)
    AIR     = AIR_<MACHINE> (default MACHINE is $DEFAULT_MACHINE)
    FREEZE  = FREEZE_<MACHINE> (default MACHINE is $DEFAULT_MACHINE)
    CHAOS   = CHAOS_<MACHINE> (default MACHINE is $DEFAULT_MACHINE)

  OPTS
    -c | --no-cache
      same as '--no-read-cache --no-write-cache'
    -w | --no-read-cache | --overwrite-cache
      skip reading from the cache (does not affect writing to the cache)
    -r | --no-write-cache | --read-only-cache
      skip writing to the cache (does not affect reading from the cache)

    --singles | singles | --single | single | --dance-single | dance-single
      same as: --game='^(dance-single|singles)\$'
    --doubles | doubles | --double | double | --dance-double | dance-double
      same as: --game='^(dance-double|doubles)\$'
    --game=GAME_REGEX
      ignore (and skip calculations for) all note-sets where
        both GAME and GAME_ABBREV do not match (case-insensitive)
        the regular expression GAME_REGEX

    --beginner | beginner
      same as: --difficulty='^beginner\$'
    --basic | basic
      same as: --difficulty='^basic\$'
    --difficult | difficult
      same as: --difficulty='^difficult\$'
    --expert | expert
      same as: --difficulty='^expert\$'
    --challenge | challenge
      same as: --difficulty='^challenge\$'
    --diff=DIFFICULTY_REGEX --difficulty=DIFFICULTY_REGEX
      ignore (and skip calculations for) all note-sets where
        both DIFF and DIFF_ABBREV does not match (case-insensitive)
        the regular expression DIFFICULTY_REGEX

    --diff-sm=DIFF_SM_REGEX
      ignore (and skip calculations for) all note-sets where
        DIFF_SM does not match (case-insensitive)
        the regular expression DIFF_SM_REGEX

    --machine=MACHINE
      MACHINE is one of the following values (case-insensitive):
        DDRA DDRSN2
      this changes the value of the following variables:
        STREAM  = STREAM_<MACHINE>
        VOLTAGE = VOLTAGE_<MACHINE>
        AIR     = AIR_<MACHINE>
        FREEZE  = FREEZE_<MACHINE>
        CHAOS   = CHAOS_<MACHINE>
      e.g.: --machine=ddrsn2
            => STREAM = STREAM_DDRSN2

    --dump
      print all variables for each GAME and DIFF (overrides --format)
      equivalent to setting FORMAT_SPEC to the concatentation of:
        %GAME.%DIFF.<VARIABLE>=%<VARIABLE>%n
      for each VARIABLE (one per line, sorted asciibetically)

    --skip-note-rows
      when formatting stats for printing, use the empty string for 'NOTE_ROWS' variable
      (NOTE_ROWS are still calculated and cached, only printing is affected)

    --format=FORMAT_SPEC
      FORMAT_SPEC can be any string, with the following printf-like replacements:
        %%                       = a literal % character
        %n                       = a newline character (\\n)
        %<VARIABLE>              = VARIABLE value
                                   e.g.: %STREAM
        %<PRINTF_MOD><VARIABLE>  = VARIABLE value, formatted with PRINTF_MOD
                                   e.g.: %05.2fSTREAM
        %<PRINTF_MOD>-<VARIABLE> = VARIABLE value, formatted with PRINTF_MOD
                                   e.g.: %05.2f-STREAM
      default=$DEFAULT_FORMAT_SPEC
         e.g.: singles | expert     | S122 | V109 | A0   | F0   | C108

      if format does not end in at least one newline, one is appended,
        unless --no-force-newline is given

      PRINTF_MOD = FLAGS|WIDTH|PRECISION|SPECIFIER
        almost any printf string, like '+08.2f',
          except:
            'width' must be a number, not '*'
            'precision' must be a number, not '.*'
            'length' (C datatype) is not allowed
            'specifier' n is not allowed
            'specifier' % is not allowed

        FLAGS
          any (or none) of \"-\", \"+\", \" \", \"#\", \"0\"
          e.g.: - 0
        WIDTH:
          missing, or a positive integer
          e.g.: 32
        PRECISION:
          missing, or a decimal point followed by a positive integer
          e.g.: .2
        SPECIFIER:
          exactly one of: d i u o x X f F e E g G a A c s
          e.g.: f

    --info
      same as: --format=\"$DEFAULT_FORMAT_SPEC\"

    -n | --no-force-newline
      do not append newlines automatically
      without this option, if FORMAT_SPEC results in output that does not end in a newline,
        a newline is appended to each formatted output

    -d
      same as: --dump --skip-note-rows --no-cache
";

sub main(@){
  my @smFiles;
  my $gameDiffFilters = {
    gameFilterRegex => undef,
    diffDDRFilterRegex => undef,
    diffSMFilterRegex => undef,
  };
  my $defaultVarsMachine = $DEFAULT_MACHINE;
  my $dump = 0;
  my $skipNoteRowsPrinting = 0;
  my $formatSpec = $DEFAULT_FORMAT_SPEC;
  my $forceNewlines = 1;
  my $readCache = 1;
  my $writeCache = 1;
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $usage;
      exit 0;
    }elsif($arg =~ /^(-c|--no-cache)$/){
      $readCache = 0;
      $writeCache = 0;
    }elsif($arg =~ /^(-w|--no-read-cache|--overwrite-cache)$/){
      $readCache = 0;
    }elsif($arg =~ /^(-r|--no-write-cache|--read-only-cache)$/){
      $writeCache = 0;
    }elsif($arg =~ /^(?:--)?(?:dance-)?(single|double)s?$/){
      $$gameDiffFilters{gameFilterRegex} = "^(dance-$1|$1s)\$";
    }elsif($arg =~ /^--game=(.+)$/){
      $$gameDiffFilters{gameFilterRegex} = $1;
    }elsif($arg =~ /^(?:--)?(beginner|basic|difficult|expert|challenge)$/){
      $$gameDiffFilters{diffDDRFilterRegex} = "^$1\$";
    }elsif($arg =~ /^--(?:diff|difficulty)=(.+)$/){
      $$gameDiffFilters{diffDDRFilterRegex} = $1;
    }elsif($arg =~ /^--(?:diff-sm)=(.+)$/){
      $$gameDiffFilters{diffSMFilterRegex} = $1;
    }elsif($arg =~ /^--machine=(DDRA|DDRSN2)$/i){
      $defaultVarsMachine = uc $1;
    }elsif($arg =~ /^--dump$/){
      $dump = 1;
    }elsif($arg =~ /^--skip-note-rows$/){
      $skipNoteRowsPrinting = 1;
    }elsif($arg =~ /^--format=(.+)$/){
      $formatSpec = $1;
    }elsif($arg =~ /^(--info)$/){
      $formatSpec = $INFO_FORMAT_SPEC;
    }elsif($arg =~ /^(-n|--no-force-newlines)$/){
      $forceNewlines = 0;
    }elsif($arg =~ /^(-d)$/){
      $dump = 1;
      $skipNoteRowsPrinting = 1;
      $readCache = 0;
      $writeCache = 0;
    }elsif(-f $arg){
      push @smFiles, $arg;
    }else{
      die "$usage\nERROR: unknown arg $arg\n";
    }
  }
  die "$usage\nERROR: missing SM_FILE\n" if @smFiles == 0;

  for my $smFile(@smFiles){
    handleSimfile(
      $smFile,
      $gameDiffFilters,
      $defaultVarsMachine,
      $dump,
      $skipNoteRowsPrinting,
      $formatSpec,
      $forceNewlines,
      $readCache,
      $writeCache,
    );
  }
}

sub handleSimfile($$$$$$$$$){
  my (
    $smFile,
    $gameDiffFilters,
    $defaultVarsMachine,
    $dump,
    $skipNoteRowsPrinting,
    $formatSpec,
    $forceNewlines,
    $readCache,
    $writeCache,
  ) = @_;

  my $smInfo = getSMInfo($smFile, $gameDiffFilters, $readCache, $writeCache);

  my @gameDiffKeys = @{$$smInfo{gameDiffKeyOrder}};

  my $stats = {};
  for my $gameDiffKey(@gameDiffKeys){
    next if isGameDiffSkipped($gameDiffFilters, $gameDiffKey);
    my $s = getNoteSetStats($smFile, $smInfo, $gameDiffKey, $readCache, $writeCache);

    #copy default machine values into plain radar variables
    for my $radarStat(qw(STREAM VOLTAGE AIR FREEZE CHAOS)){
      my $machineVal = $$s{"${radarStat}_${defaultVarsMachine}"};
      $$s{$radarStat} = $machineVal;
    }

    $$stats{$gameDiffKey} = $s;
  }

  for my $gameDiffKey(@gameDiffKeys){
    my $s = $$stats{$gameDiffKey};
    next if isGameDiffSkipped($gameDiffFilters, $gameDiffKey);
    next if not defined $s;

    if($dump){
      $formatSpec = "";
      for my $varName(sort keys %$s){
        $formatSpec .= "%GAME.%DIFF.$varName=%$varName%n";
      }
    }

    $$s{NOTE_ROWS} = '' if $skipNoteRowsPrinting;

    print formatStats($formatSpec, $forceNewlines, $s);
  }
}

sub formatStats($$$){
  my ($formatSpec, $forceNewlines, $stats) = @_;

  my $s = $formatSpec;
  $s =~ s/&/&amp;/g;
  $s =~ s/%%/&boing;/g;

  $s =~ s/%n/\n/g;

  my %okCompressedVarnames = map {$_ => 1} @COMPRESSED_VARIABLE_NAMES;

  my $varRegex = join "|", sort {length $b <=> length $a} keys %$stats;
  my $printfModRegex = '[ \-+#0]*\d*(?:\.\d+)?[diuoxXfFeEgGaAcs]';
  while($s =~ s/%((?:$printfModRegex)?)-?($varRegex)/&var;/){
    my ($printfMod, $varName) = ($1, $2);
    my $val = $$stats{$varName};
    if(defined $okCompressedVarnames{$varName}){
      $val = boingDecompressString($val);
    }
    $val =~ s/&/&amp;/g;
    $val =~ s/%/&boing;/g;
    if(length $printfMod > 0){
      $val = sprintf "%$printfMod", $val;
    }
    $s =~ s/&var;/$val/g;
  }

  if($s =~ /%/){
    die "ERROR: format-spec contains unknown replacement var \"$formatSpec\"\n";
  }

  $s =~ s/&boing;/%/g;
  $s =~ s/&amp;/&/g;

  if($forceNewlines and $s !~ /[\r\n]+$/){
    $s .= "\n";
  }

  return $s;
}

sub getSongRowCount($){
  my ($rows) = @_;

  my $rowCount = @$rows;
  #remove trailing 0-only-rows (empty rows after the last note)
  #  leading rows before the first note DO count for the song duration
  for(my $i=$#$rows; $i>=0; $i--){
    if($$rows[$i] !~ /^0+$/){
      last;
    }
    $rowCount--;
  }

  return $rowCount;
}

sub getSongDuration($$$){
  my ($rows, $bpmsByRow, $stopsByRow) = @_;
  my $songDurS = 0;

  my $rowCount = getSongRowCount($rows);

  my @bpmRows = sort {$a <=> $b} keys %$bpmsByRow;
  for(my $i=0; $i<@bpmRows; $i++){
    my $startRow = $bpmRows[$i];
    my $endRow;
    if($i+1 < @bpmRows){
      $endRow = $bpmRows[$i+1];
    }else{
      $endRow = $rowCount - 1; #the last row happens instantaneously, apparently
    }

    my $bpm = $$bpmsByRow{$startRow};
    my $beatsPerSecond = $bpm/60.0;

    my $elapsedRows = $endRow - $startRow;
    my $elapsedBeats = $elapsedRows / $ROWS_PER_BEAT; #rows are 1/192 notes in 4/4 measures

    $songDurS += $elapsedBeats / $beatsPerSecond;
  }

  for my $stopValS(values %$stopsByRow){
    $songDurS += $stopValS;
  }

  return $songDurS;
}

sub getNoteCounts($){
  my ($rows) = @_;

  my $noteCounts = {
    COUNT_NOTE_ROWS  => 0,
    COUNT_TAP_ROWS   => 0,
    COUNT_HOLD_ROWS  => 0,
    COUNT_ROLL_ROWS  => 0,
    COUNT_JUMP_ROWS  => 0,
    COUNT_MINE_ROWS  => 0,
    COUNT_SHOCK_ROWS => 0,
    COUNT_TAPS       => 0,
    COUNT_HOLDS      => 0,
    COUNT_ROLLS      => 0,
    COUNT_MINES      => 0,
  };
  for my $row(@$rows){
    $$noteCounts{COUNT_NOTE_ROWS}++  if $row =~ /[124]/;
    $$noteCounts{COUNT_TAP_ROWS}++   if $row =~ /[1]/;
    $$noteCounts{COUNT_HOLD_ROWS}++  if $row =~ /[2]/;
    $$noteCounts{COUNT_ROLL_ROWS}++  if $row =~ /[4]/;
    $$noteCounts{COUNT_JUMP_ROWS}++  if $row =~ /[124].*[124]/;
    $$noteCounts{COUNT_MINE_ROWS}++  if $row =~ /[M]/;
    $$noteCounts{COUNT_SHOCK_ROWS}++ if $row =~ /^M+$/; #"shocks" are mine-only rows

    $$noteCounts{COUNT_TAPS}  += $row =~ /1/;
    $$noteCounts{COUNT_HOLDS} += $row =~ /2/;
    $$noteCounts{COUNT_ROLLS} += $row =~ /4/;
    $$noteCounts{COUNT_MINES} += $row =~ /M/;
  }

  return $noteCounts;
}

sub getTotalFreezeRowCount($){
  my ($rows) = @_;
  my @curFreezes;

  my $frozenRowCount = 0;
  for my $row(@$rows){
    my @holdArrows;
    my @releaseArrows;

    my @arrows = split '', $row;
    for(my $i=0; $i<@arrows; $i++){
      if($arrows[$i] =~ /[24]/){    #hold or roll start
        push @holdArrows, $i;
      }elsif($arrows[$i] =~ /[3]/){ #hold or roll end
        push @releaseArrows, $i;
      }
    }

    #count this new row for all current freezes, regardless of holds/releases
    for my $freeze(@curFreezes){
      $frozenRowCount++;
    }

    #remove released freezes
    for my $arrow(@releaseArrows){
      for my $freeze(@curFreezes){
        $freeze = [grep {$_ ne $arrow} @$freeze];
      }
      @curFreezes = grep {@$_ > 0} @curFreezes;
    }

    #add new held freeze
    if(@holdArrows > 0){
      my $freeze = [@holdArrows];
      push @curFreezes, $freeze;
    }
  }
  return $frozenRowCount;
}

sub getMaxMeasureDensity($){
  my ($rows) = @_;

  my $startRow = 0;
  my $endRow = $ROWS_PER_MEASURE-1;

  if($endRow > $#$rows){
    $endRow = $#$rows;
  }

  my $curDensity = 0 + grep {/[124M]/} @$rows[$startRow..$endRow];

  my $maxDensity = $curDensity;
  while($endRow < @$rows - 1){
    my $removedMeasure = $$rows[$startRow];
    $startRow++;
    $endRow++;
    my $addedMeasure = $$rows[$endRow];

    $curDensity-- if $removedMeasure =~ /[124M]/;
    $curDensity++ if $addedMeasure =~ /[124M]/;
    if($curDensity > $maxDensity){
      $maxDensity = $curDensity;
    }
  }

  return $maxDensity;
}

sub bpmToSecondsPerRow($){
  my ($bpm) = @_;
  my $beatsPerSec = $bpm / 60.0;
  my $rowsPerSec = $ROWS_PER_BEAT * $beatsPerSec;
  my $secPerRow = 1 / $rowsPerSec;
  return $secPerRow;
}

#remove rows with negative or very large bpms
#  fairly expensive if there are warps, but fast if there are no warps
sub removeWarps($$$){
  my ($rows, $bpmsByRow, $stopsByRow) = @_;

  my $isWarp = 0;
  my $anyWarps = 0;
  my $indexOffset = 0;
  my %indexOldToNew;
  for(my $row=0; $row<@$rows; $row++){
    my $bpm = $$bpmsByRow{$row};
    if(defined $bpm){
      if($bpm < 0 || $bpm > 109713){
        $isWarp = 1;
        $anyWarps = 1;
      }else{
        $isWarp = 0;
      }
    }
    if($isWarp){
      $indexOffset++;
    }else{
      $indexOldToNew{$row} = $row - $indexOffset;
    }
  }

  if($anyWarps){
    my @newRows;
    my %newBpmsByRow;
    my %newStopsByRow;
    for my $oldIndex(sort {$a <=> $b} keys %indexOldToNew){
      push @newRows, $$rows[$oldIndex];
      my $newIndex = $indexOldToNew{$oldIndex};
      $newBpmsByRow{$newIndex} = $$bpmsByRow{$oldIndex};
      $newStopsByRow{$newIndex} = $$stopsByRow{$oldIndex};
    }

    $rows = \@newRows;
    $bpmsByRow = \%newBpmsByRow;
    $stopsByRow = \%newStopsByRow;
  }

  return ($rows, $bpmsByRow, $stopsByRow);
}

sub calculateNotesPerSecondInfo($$$){
  my ($rows, $bpmsByRow, $stopsByRow) = @_;
  my $songDurS = 0;

 ($rows, $bpmsByRow, $stopsByRow) = removeWarps($rows, $bpmsByRow, $stopsByRow);

  my @bpmChangeRows = sort {$a <=> $b} keys %$bpmsByRow;
  my $firstBpm = $$bpmsByRow{$bpmChangeRows[0]};

  #seconds until the next row (not the next note)
  #  defined for the last row as if there was an empty row after it, at the same bpm
  my @rowDurs;

  my $curSecPerRow = bpmToSecondsPerRow($firstBpm);
  for(my $row=0; $row<=@$rows; $row++){
    $curSecPerRow = bpmToSecondsPerRow($$bpmsByRow{$row}) if defined $$bpmsByRow{$row};

    my $dur = $curSecPerRow;
    if(defined $$stopsByRow{$row}){
      $dur += $$stopsByRow{$row}; #stops are immediately AFTER the row
    }
    push @rowDurs, $dur;
  }

  my %okNoteRows;
  for(my $row=0; $row<@$rows; $row++){
    $okNoteRows{$row} = 1 if $$rows[$row] =~ /[124]/;
  }

  my $maxNps = 0;

  # slice note rows into (roughly) 1-second segments,
  #   allowing segments to overlap,
  #   and select the segment with the most note rows
  # (roughly 1.0s, means max-note-rows-per-sec may be fractional)
  #
  #   -only consider at segments of AT MOST one second
  #   -only consider segments that start on a note
  #     (i.e.: this results in a MINIMUM of note-rows-per=second = 1)
  #
  #   -never consider segments that are ENTIRELY part of another segment
  #     (i.e.: only consider the longest possible segment, as close to 1.0s as possible)
  #

  # MAX_DURATION_S: maximum length of segment in seconds
  my %varsBySuffix = (
    NOTE_ROWS_PER_SEC => {MAX_DURATION_S => 1.0},
  );

  my $npsInfo = {};
  for my $varSuffix(sort keys %varsBySuffix){
    my %varInfo = %{$varsBySuffix{$varSuffix}};
    my $maxDurationS = $varInfo{MAX_DURATION_S};

    my $maxNps = 0;
    for(my $row=0; $row<$#$rows; $row++){
      #skip segments that do not start with a note row
      #    -at least one segment that has the peak-NPS-per-segment
      #      will necessarily start with a note row
      #    -if a segment doesn't start with a note row, moving the segment down
      #      a note row can only increase NPS
      next if not $okNoteRows{$row};

      my $segmentStartRow = $row;
      my $segmentEndRow = $row;
      my $segmentDurationS = 0;
      while(1){
        my $segmentEndRowAfterNextRow = $segmentEndRow + 1;
        my $durAfterNextRow = $segmentDurationS + $rowDurs[$segmentEndRow];
        if($segmentEndRowAfterNextRow > $#$rows){
          #last segment
          last;
        }elsif(defined $maxDurationS and $durAfterNextRow > $maxDurationS){
          last;
        }else{
          $segmentEndRow = $segmentEndRowAfterNextRow;
          $segmentDurationS = $durAfterNextRow;
        }
      }

      #segment ends after the END of the last note row
      #  i.e.: infinitesimally before the start of the next note row after the segment
      $segmentDurationS += $rowDurs[$segmentEndRow];

      my $segmentNoteCount = grep {$okNoteRows{$_}} $segmentStartRow..$segmentEndRow;

      if($segmentDurationS >= 0.01){
        my $nps = $segmentNoteCount / $segmentDurationS;
        if($nps > $maxNps){
          $maxNps = $nps;
        }
      }else{
        #skip very short segments
        next;
      }
    }
    $$npsInfo{"MAX_$varSuffix"} = $maxNps;
  }

  return $npsInfo;
}


sub getTotalNoteIrregularity($){
  my ($rows) = @_;
  my $totalIrregularity = 0;

  my $previousNoteIndex = undef;
  for(my $i=0; $i<@$rows; $i++){
    my $row = $$rows[$i];
    next if $row !~ /[124M]/; #ignore rows without jumps, taps or mines

    #timing of the notes within a measure
    #  this corresponds to arrow 'color' in certain noteskins,
    #  although mines/shocks work the same way and dont have color
    my $noteTypeIrregularity;
    if($i % int($ROWS_PER_MEASURE/4) == 0){
      #1/4 note row => red arrows
      $noteTypeIrregularity = 0; #1/4 notes have zero irregularity
    }elsif($i % int($ROWS_PER_MEASURE/8) == 0){
      #1/8 note row => blue arrows
      $noteTypeIrregularity = 0.5;
    }elsif($i % int($ROWS_PER_MEASURE/16) == 0){
      #1/16 note row => yellow arrows
      $noteTypeIrregularity = 1.0;
    }else{
      #anything else (1/12, 1/24, 1/32, 1/48, 1/64, 1/92) => purple/green/gray arrows
      $noteTypeIrregularity = 1.25;
    }

    my $irregularity;
    if(defined $previousNoteIndex){
      #how many rows of 1/192 notes between this note and the previous
      my $intervalRows = $i-$previousNoteIndex;

      #how much of a measure is between this note and the previous
      #larger values mean less irregularity
      #  a single 1/4 note is 0.25
      #  a single 1/16 note is 0.0625
      #  three 1/16 notes is 0.1875
      #  eight 1/4 notes is 2
      my $intervalFractionalMeasures = $intervalRows/$ROWS_PER_MEASURE;

      #each arrow has its own irregularity, so 2-arrow jumps count twice,
      #  and shocks count 4x in singles and 8x in doubles
      my $arrowCount = 0 + grep {$_ =~ /[124M]/} split //, $row;

      $irregularity = $arrowCount * ($noteTypeIrregularity/$intervalFractionalMeasures);
    }else{
      #first note has no irregularity
      $irregularity = 0;
    }

    $totalIrregularity += $irregularity;
    $previousNoteIndex = $i;
  }
  return $totalIrregularity;
}

sub getBPMChangeAmount($$){
  my ($bpmsByRow, $stopsByRow) = @_;
  my $bpmChangeAmount = 0;

  my %bpmStopRows = map {$_ => 1} (keys %$bpmsByRow, keys %$stopsByRow);

  my @allBPMOrStopRows = sort {$a <=> $b} keys %bpmStopRows;

  my $curBPM = undef;
  for my $row(@allBPMOrStopRows){
    my $newBPM;
    my $bpmDiff = 0;
    if(defined $$bpmsByRow{$row}){
      $newBPM = $$bpmsByRow{$row};

      if(defined $curBPM){
        $bpmDiff = $newBPM - $curBPM;
        $bpmDiff = 0-$bpmDiff if $bpmDiff < 0;
      }
    }

    if(defined $$stopsByRow{$row}){
      $bpmDiff = defined $newBPM ? $newBPM : $curBPM;
    }

    my $firstBPMChange = defined $newBPM && not defined $curBPM ? 1 : 0;

    if(not $firstBPMChange){
      $bpmChangeAmount += $bpmDiff;
    }
    $curBPM = $newBPM if defined $newBPM;
  }

  return $bpmChangeAmount;
}

sub formatDDRDiff($){
  my ($diff) = @_;
  if($diff =~ /^(Beginner)$/i){
    return "beginner";
  }elsif($diff =~ /^(Easy)$/i){
    return "basic";
  }elsif($diff =~ /^(Medium)$/i){
    return "difficult";
  }elsif($diff =~ /^(Hard)$/i){
    return "expert";
  }elsif($diff =~ /^(Expert)$/i){
    return "challenge";
  }elsif($diff =~ /^(Challenge)$/i){
    return "challenge";
  }else{
    return $diff;
  }
}

sub getNoteSetStats($$$$$){
  my ($smFile, $smInfo, $gameDiffKey, $readCache, $writeCache) = @_;
  my $stats = undef;
  $stats = readNoteSetStatsCache($smFile, $gameDiffKey) if $readCache;
  if(not defined $stats){
    $stats = calculateNoteSetStats($smInfo, $gameDiffKey);
    writeNoteSetStatsCache($smFile, $gameDiffKey, $stats) if $writeCache;
  }
  return $stats;
}

sub isNoteSetStatsCached($$){
  my ($smFile, $gameDiffKey) = @_;
  my $cacheDir = getCacheDir($smFile);
  if(-f "$cacheDir/stats-$gameDiffKey"){
    return 1;
  }else{
    return 0;
  }
}
sub readNoteSetStatsCache($$){
  my ($smFile, $gameDiffKey) = @_;
  my $cacheDir = getCacheDir($smFile);
  if(not -f "$cacheDir/stats-$gameDiffKey"){
    return undef;
  }
  open FH, "<", "$cacheDir/stats-$gameDiffKey";
  my @lines = <FH>;
  close FH;
  my $stats = {};
  for my $line(@lines){
    if($line =~ /^(\w+)=(.+)$/){
      $$stats{$1} = $2;
    }
  }

  #recalculate game/diff abbreviations
  $$stats{GAME_ABBREV} = abbrevGame($$stats{GAME});
  $$stats{DIFF_ABBREV} = abbrevDiff($$stats{DIFF});

  $$stats{SM_RADAR} = "" if not defined $$stats{SM_RADAR};

  return $stats;
}
sub writeNoteSetStatsCache($$$){
  my ($smFile, $gameDiffKey, $stats) = @_;
  my $cacheDir = getCacheDir($smFile);
  open FH, ">", "$cacheDir/stats-$gameDiffKey";
  print FH "$_=$$stats{$_}\n" foreach sort keys %$stats;
  close FH;
}

sub calculateNoteSetStats($$){
  my ($smInfo, $gameDiffKey) = @_;
  my $noteSetInfo = $$smInfo{noteSetInfoByGameDiffKey}{$gameDiffKey};
  my $s = {
    GAME                      => $$noteSetInfo{game},
    DIFF_SM                   => $$noteSetInfo{diff},
    SM_FEET                   => $$noteSetInfo{smFeet},
    SM_RADAR                  => $$noteSetInfo{smRadar},
    SONG_NAME                 => $$smInfo{songName},
    SONG_NAME_TRANSLIT        => $$smInfo{songNameTranslit},
    SONG_NAME_ID              => $$smInfo{songNameId},
  };
  $$s{DIFF} = formatDDRDiff($$s{DIFF_SM});
  $$s{GAME_ABBREV} = abbrevGame($$s{GAME});
  $$s{DIFF_ABBREV} = abbrevDiff($$s{DIFF});

  my $rows = $$noteSetInfo{expandedNoteRows};

  my $bpmsByRow;
  if(defined $$noteSetInfo{bpmsByRow}){
    $bpmsByRow = $$noteSetInfo{bpmsByRow};
  }else{
    $bpmsByRow = $$smInfo{bpmsByRow};
  }

  my $stopsByRow;
  if(defined $$noteSetInfo{stopsByRow}){
    $stopsByRow = $$noteSetInfo{stopsByRow};
  }else{
    $stopsByRow = $$smInfo{stopsByRow};
  }

  #analysis + data-collection
  $s = {%$s,                     %{getNoteCounts($rows)},
    SONG_DUR                  => getSongDuration($rows, $bpmsByRow, $stopsByRow),
    SONG_ROW_COUNT            => getSongRowCount($rows),
    MAX_MEASURE_DENSITY       => getMaxMeasureDensity $rows,
    TOTAL_FREEZE_ROW_COUNT    => getTotalFreezeRowCount $rows,
    TOTAL_NOTE_IRREGULARITY   => getTotalNoteIrregularity $rows,
    BPM_CHANGE_AMOUNT         => getBPMChangeAmount($bpmsByRow, $stopsByRow),
  };

  $s = {%$s, %{calculateNotesPerSecondInfo($rows, $bpmsByRow, $stopsByRow)}},

  #meaningful calculated values
  $$s{SONG_DUR_FMT}              = formatTimeMSS $$s{SONG_DUR};
  $$s{NOTE_ROWS}                 = join ",", @$rows;
  $$s{BPM_ROWS}                  = join ",", map {"$_=$$bpmsByRow{$_}"} sort {$a <=> $b} keys %$bpmsByRow;
  $$s{STOP_ROWS}                 = join ",", map {"$_=$$stopsByRow{$_}"} sort {$a <=> $b} keys %$stopsByRow;
  $$s{CHECKSUM}                  = songChecksum($$s{NOTE_ROWS}, $$s{BPM_ROWS}, $$s{STOP_ROWS});
  $$s{SONG_BEAT_COUNT}           = int($$s{SONG_ROW_COUNT}/$ROWS_PER_BEAT + 0.5);
  $$s{TOTAL_NOTES}               = $$s{COUNT_NOTE_ROWS} + $$s{COUNT_SHOCK_ROWS};
  $$s{TOTAL_JUMPS_SHOCKS}        = $$s{COUNT_JUMP_ROWS} + $$s{COUNT_SHOCK_ROWS};
  $$s{NOTES_PER_MIN}             = 60 * ($$s{TOTAL_NOTES}) / $$s{SONG_DUR};
  $$s{AVG_BPM}                   = 60 * ($$s{SONG_ROW_COUNT}/$ROWS_PER_BEAT) / $$s{SONG_DUR};
  $$s{MAX_DENSITY_PER_MIN}       = $$s{AVG_BPM}*$$s{MAX_MEASURE_DENSITY}/4;
  $$s{JUMPS_SHOCKS_PER_MIN}      = 60 * $$s{TOTAL_JUMPS_SHOCKS} / $$s{SONG_DUR};
  $$s{FREEZE_BEAT_COUNT}         = $$s{TOTAL_FREEZE_ROW_COUNT}/$ROWS_PER_BEAT;
  $$s{FREEZE_RATIO_10K}          = $$s{SONG_BEAT_COUNT} == 0 ? 0 : 10000 * $$s{FREEZE_BEAT_COUNT} / $$s{SONG_BEAT_COUNT};
  $$s{BPM_CHANGE_AMOUNT_PER_MIN} = 60 * $$s{BPM_CHANGE_AMOUNT} / $$s{SONG_DUR};
  $$s{OVERALL_IRREGULARITY}      = $$s{TOTAL_NOTE_IRREGULARITY} * (1 + $$s{BPM_CHANGE_AMOUNT_PER_MIN}/1500);
  $$s{IRREG_PER_CENTISECOND}     = 100 * $$s{OVERALL_IRREGULARITY} / $$s{SONG_DUR};

  my $singles = $$s{GAME} =~ /double/i ? 0 : 1;
  my $doubles = $$s{GAME} =~ /double/i ? 1 : 0;
  my $any = 1;

  my @radarPermutations = (
    ["STREAM_DDRA",   [$singles, $$s{NOTES_PER_MIN} >= 300] => ($$s{NOTES_PER_MIN}-139)*100/161],
    ["STREAM_DDRA",   [$doubles, $$s{NOTES_PER_MIN} >= 300] => ($$s{NOTES_PER_MIN}-183)*100/117],
    ["STREAM_DDRA",   [$any,     $$s{NOTES_PER_MIN} < 300]  => $$s{NOTES_PER_MIN}/3],
    ["STREAM_DDRSN2", [$singles, $$s{NOTES_PER_MIN} >= 300] => ($$s{NOTES_PER_MIN}-203)*100/97],
    ["STREAM_DDRSN2", [$doubles, $$s{NOTES_PER_MIN} >= 300] => ($$s{NOTES_PER_MIN}-205)*20/19],
    ["STREAM_DDRSN2", [$any,     $$s{NOTES_PER_MIN} < 300]  => $$s{NOTES_PER_MIN}/3],

    ["VOLTAGE_DDRA",   [$any, $$s{MAX_DENSITY_PER_MIN} >= 600] => ($$s{MAX_DENSITY_PER_MIN}+594)*100/1194],
    ["VOLTAGE_DDRA",   [$any, $$s{MAX_DENSITY_PER_MIN} < 600]  => $$s{MAX_DENSITY_PER_MIN}/6],
    ["VOLTAGE_DDRSN2", [$any, $$s{MAX_DENSITY_PER_MIN} >= 600] => ($$s{MAX_DENSITY_PER_MIN}+102)*100/702],
    ["VOLTAGE_DDRSN2", [$any, $$s{MAX_DENSITY_PER_MIN} < 600]  => $$s{MAX_DENSITY_PER_MIN}/6],

    ["AIR_DDRA",   [$singles, $$s{JUMPS_SHOCKS_PER_MIN} >= 55] => ($$s{JUMPS_SHOCKS_PER_MIN}+36)*100/91],
    ["AIR_DDRA",   [$doubles, $$s{JUMPS_SHOCKS_PER_MIN} >= 55] => ($$s{JUMPS_SHOCKS_PER_MIN}+35)*10/9],
    ["AIR_DDRA",   [$any,     $$s{JUMPS_SHOCKS_PER_MIN} < 55]  => $$s{JUMPS_SHOCKS_PER_MIN}*20/11],
    ["AIR_DDRSN2", [$any,     $$s{JUMPS_SHOCKS_PER_MIN} >= 55] => ($$s{JUMPS_SHOCKS_PER_MIN}-1)*50/27],
    ["AIR_DDRSN2", [$any,     $$s{JUMPS_SHOCKS_PER_MIN} < 55]  => $$s{JUMPS_SHOCKS_PER_MIN}*20/11],

    ["FREEZE_DDRA",   [$singles, $$s{FREEZE_RATIO_10K} >= 3500] => ($$s{FREEZE_RATIO_10K}+2484)*100/5984],
    ["FREEZE_DDRA",   [$doubles, $$s{FREEZE_RATIO_10K} >= 3500] => ($$s{FREEZE_RATIO_10K}+2246)*100/5746],
    ["FREEZE_DDRA",   [$any,     $$s{FREEZE_RATIO_10K} < 3500]  => $$s{FREEZE_RATIO_10K}/35],
    ["FREEZE_DDRSN2", [$singles, $$s{FREEZE_RATIO_10K} >= 3500] => ($$s{FREEZE_RATIO_10K}+2484)*100/5984],
    ["FREEZE_DDRSN2", [$doubles, $$s{FREEZE_RATIO_10K} >= 3500] => ($$s{FREEZE_RATIO_10K}+2246)*100/5746],
    ["FREEZE_DDRSN2", [$any,     $$s{FREEZE_RATIO_10K} < 3500]  => $$s{FREEZE_RATIO_10K}/35],

    ["CHAOS_DDRA",   [$singles, $$s{IRREG_PER_CENTISECOND} >= 2000] => ($$s{IRREG_PER_CENTISECOND}+21605)*100/23605],
    ["CHAOS_DDRA",   [$doubles, $$s{IRREG_PER_CENTISECOND} >= 2000] => ($$s{IRREG_PER_CENTISECOND}+16628)*100/18629],
    ["CHAOS_DDRA",   [$any,     $$s{IRREG_PER_CENTISECOND} < 2000]  => $$s{IRREG_PER_CENTISECOND}/20],
    ["CHAOS_DDRSN2", [$singles, $$s{IRREG_PER_CENTISECOND} >= 2000] => ($$s{IRREG_PER_CENTISECOND}+21605)*100/23605],
    ["CHAOS_DDRSN2", [$doubles, $$s{IRREG_PER_CENTISECOND} >= 2000] => ($$s{IRREG_PER_CENTISECOND}+16628)*100/18628],
    ["CHAOS_DDRSN2", [$any,     $$s{IRREG_PER_CENTISECOND} < 2000]  => $$s{IRREG_PER_CENTISECOND}/20],
  );
  for my $radarPerm(@radarPermutations){
    my ($radarStat, $conditions, $val) = @$radarPerm;
    my $countCondOK = grep {$_} @$conditions;
    my $countCondTotal = @$conditions;
    $$s{$radarStat} = $val if $countCondOK == $countCondTotal;
  }

  for my $varName(@COMPRESSED_VARIABLE_NAMES){
    if(defined $$s{$varName}){
      $$s{$varName} = boingCompressString($$s{$varName});
    }
  }

  return $s;
}

sub getSMInfo($$$$){
  my ($smFile, $gameDiffFilters, $readCache, $writeCache) = @_;
  my $smInfo = undef;
  $smInfo = readSMInfoCache $smFile, $gameDiffFilters if $readCache;
  if(not defined $smInfo){
    $smInfo = parseSMFile $smFile;
    writeSMInfoCache($smFile, $smInfo) if $writeCache;
  }
  return $smInfo;
}

sub readSMInfoCache($$){
  my ($smFile, $gameDiffFilters) = @_;
  my $cacheDir = getCacheDir($smFile);
  if(not -f "$cacheDir/smInfo"){
    return undef;
  }

  my $smInfoTxt = `cat "$cacheDir/smInfo" 2>/dev/null`;
  my $smInfo = {};
  $$smInfo{songName} = $1         if $smInfoTxt =~ /^songName=(.*)$/m;
  $$smInfo{songNameTranslit} = $1 if $smInfoTxt =~ /^songNameTranslit=(.*)$/m;
  $$smInfo{songNameId} = $1       if $smInfoTxt =~ /^songNameId=(.*)$/m;
  $$smInfo{bpms} = $1             if $smInfoTxt =~ /^bpms=(.*)$/m;
  $$smInfo{stops} = $1            if $smInfoTxt =~ /^stops=(.*)$/m;
  my $gameDiffKeyOrderCsv = $1    if $smInfoTxt =~ /^gameDiffKeyOrder=(.*)$/m;

  $$smInfo{gameDiffKeyOrder} = [split /,/, $gameDiffKeyOrderCsv];
  $$smInfo{bpmsByRow} = convertValuesByBeatToValuesByRow($$smInfo{bpms});
  $$smInfo{stopsByRow} = convertValuesByBeatToValuesByRow($$smInfo{stops});

  $$smInfo{noteSetInfoByGameDiffKey} = {};
  for my $gameDiffKey(@{$$smInfo{gameDiffKeyOrder}}){
    if(not -f "$cacheDir/noteSetInfo-$gameDiffKey"){
      return undef;
    }
    my $noteSetInfoTxt = `cat "$cacheDir/noteSetInfo-$gameDiffKey" 2>/dev/null`;
    my $noteSetInfo = {};
    $$noteSetInfo{game} = $1    if $noteSetInfoTxt =~ /^game=(.+)$/m;
    $$noteSetInfo{diff} = $1    if $noteSetInfoTxt =~ /^diff=(.+)$/m;
    $$noteSetInfo{smFeet} = $1  if $noteSetInfoTxt =~ /^smFeet=(.+)$/m;
    $$noteSetInfo{smRadar} = $1 if $noteSetInfoTxt =~ /^smRadar=(.+)$/m;
    $$noteSetInfo{bpms} = $1    if $noteSetInfoTxt =~ /^bpms=(.+)$/m;
    $$noteSetInfo{stops} = $1   if $noteSetInfoTxt =~ /^stops=(.+)$/m;

    my $bpmsByRow = undef;
    if(defined $$noteSetInfo{bpms}){
      $bpmsByRow = convertValuesByBeatToValuesByRow($$noteSetInfo{bpms});
    }
    $$noteSetInfo{bpmsByRow} = $bpmsByRow;

    my $stopsByRow = undef;
    if(defined $$noteSetInfo{stops}){
      $stopsByRow = convertValuesByBeatToValuesByRow($$noteSetInfo{stops});
    }
    $$noteSetInfo{stopsByRow} = $stopsByRow;

    my $noteRowsCacheFilePrefix = "$cacheDir/expandedNoteRows-$gameDiffKey";

    my $skipExpandedNoteRowsCache =
      isGameDiffSkipped($gameDiffFilters, $gameDiffKey)
        or isNoteSetStatsCached($smFile, $gameDiffKey);

    if($skipExpandedNoteRowsCache){
      #skip reading note rows if game-diff is skipped,
      #  or if note-set-stats calculated+cached
      $$noteSetInfo{expandedNoteRows} = undef;
    }else{
      my @expandedNoteRows;
      if(-f "$noteRowsCacheFilePrefix"){
        open FH, "<", $noteRowsCacheFilePrefix
          or die "ERROR: could not read $noteRowsCacheFilePrefix\n$!\n";
        @expandedNoteRows = <FH>;
        close FH;
      }elsif(-f "$noteRowsCacheFilePrefix.gz" and isExecAvailable("gunzip")){
        open FH, "-|", "gunzip", "-c", "$cacheDir/expandedNoteRows-$gameDiffKey";
        @expandedNoteRows = <FH>;
        close FH;
      }

      chomp foreach @expandedNoteRows;
      $$noteSetInfo{expandedNoteRows} = [@expandedNoteRows];
    }


    $$smInfo{noteSetInfoByGameDiffKey}{$gameDiffKey} = $noteSetInfo;
  }

  return $smInfo;
}
sub writeSMInfoCache($$){
  my ($smFile, $smInfo) = @_;
  my $cacheDir = getCacheDir($smFile);
  system "rm", "-rf", $cacheDir;
  system "mkdir", "-p", $cacheDir;
  open FH, "> $cacheDir/smInfo";
  print FH ""
    . "songName=$$smInfo{songName}\n"
    . "songNameTranslit=$$smInfo{songNameTranslit}\n"
    . "songNameId=$$smInfo{songNameId}\n"
    . "bpms=$$smInfo{bpms}\n"
    . "stops=$$smInfo{stops}\n"
    . "gameDiffKeyOrder=" . join(",", @{$$smInfo{gameDiffKeyOrder}}) . "\n"
    ;
  close FH;

  for my $gameDiffKey(@{$$smInfo{gameDiffKeyOrder}}){
    my $noteSetInfo = $$smInfo{noteSetInfoByGameDiffKey}{$gameDiffKey};
    open FH, "> $cacheDir/noteSetInfo-$gameDiffKey";
    print FH ""
      . "game=$$noteSetInfo{game}\n"
      . "diff=$$noteSetInfo{diff}\n"
      . "smFeet=$$noteSetInfo{smFeet}\n"
      ;
    print FH "smRadar=$$noteSetInfo{smRadar}\n" if defined $$noteSetInfo{smRadar};
    print FH "bpms=$$noteSetInfo{bpms}\n" if defined $$noteSetInfo{bpms};
    print FH "stops=$$noteSetInfo{stops}\n" if defined $$noteSetInfo{stops};
    close FH;

    open FH, "> $cacheDir/expandedNoteRows-$gameDiffKey";
    print FH "$_\n" foreach @{$$noteSetInfo{expandedNoteRows}};
    close FH;

    if(isExecAvailable("gzip")){
      system "gzip", "$cacheDir/expandedNoteRows-$gameDiffKey";
    }
  }
}

sub songChecksum($$$){
  my ($noteRows, $bpmRows, $stopRows) = @_;

  if(isExecAvailable("sha256sum")){
    return getChecksumStr("$noteRows\%$bpmRows\%$stopRows");
  }else{
    return undef;
  }
}

sub parseSMFile($){
  my ($smFile) = @_;
  my $sm = readFile $smFile;

  my $smInfo = {
    songName                 => undef,
    songNameTranslit         => undef,
    songNameId               => undef,
    bpms                     => undef,
    bpmsByRow                => undef,
    stops                    => undef,
    stopsByRow               => undef,
    noteSetInfoByGameDiffKey => {},
    gameDiffKeyOrder         => [],
  };

  if($sm !~ /#TITLE:([^\r\n]+);/i){
    my $fileName = $smFile;
    $fileName =~ s/.*\///;
    $fileName =~ s/\.\w+$//;
    $$smInfo{songName} = $fileName;
    print STDERR "WARNING: could not read TITLE from $smFile, using $fileName\n";
  }else{
    $$smInfo{songName} = $1;
  }
  if($sm !~ /#TITLETRANSLIT:([^\r\n]+);/i){
    $$smInfo{songNameTranslit} = $$smInfo{songName}; #copy out of title if tranlist not set
  }else{
    $$smInfo{songNameTranslit} = $1;
  }

  $$smInfo{songNameId} = extractSongNameId($$smInfo{songNameTranslit});

  if($sm !~ /#BPMS:([^;]+);/i){
    die "ERROR: could not read BPMs from $smFile\n";
  }else{
    $$smInfo{bpms} = $1;
  }
  $$smInfo{bpmsByRow} = convertValuesByBeatToValuesByRow($$smInfo{bpms});

  if($sm !~ /#STOPS:([^;]*);/i){
    $$smInfo{stops} = ""; #STOPS is optional
  }else{
    $$smInfo{stops} = $1;
  }
  $$smInfo{stopsByRow} = convertValuesByBeatToValuesByRow($$smInfo{stops});

  my $reName = '(?:[a-zA-Z0-9\-_]+)';

  #in case one #NOTES doesnt have a ";", add it before the next
  $sm =~ s/^#NOTES/;\n#NOTES/gm;

  my @noteSetInfos;

  #SM files
  while($sm =~ /
    \#NOTES                  \s*:\s*
    (?<game>$reName)         \s*:\s*
    [^:]*?                   \s*:\s*
    (?<difficulty>$reName)   \s*:\s*
    (?<smFeet>[^:]*?)        \s*:\s*
    (?<smRadar>[^:]*?)       \s*:\s*
    (?<notes>[^;:]+?)        (?:[;:]|$)
  /gsxi){
    my ($game, $difficulty, $smFeet, $smRadar, $notes) = (
      $+{game}, $+{difficulty}, $+{smFeet}, $+{smRadar}, $+{notes});

    $smFeet = "" if $smFeet !~ /^\d+$/;

    if($notes =~ /^\s*$/s){
      print STDERR "WARNING: skipping empty note set for game=$game diff=$difficulty\n";
      next;
    }

    push @noteSetInfos, {
      game    => $game,
      diff    => $difficulty,
      smFeet  => $smFeet,
      smRadar => $smRadar,
      notes   => $notes,
      bpms    => undef,
      stops   => undef,
    };
  }

  #SSC files
  my @sscNoteSets = $sm =~ /\#NOTEDATA\s*:.*?#NOTES\s*:[^;]*;/gsi;
  for my $noteSet(@sscNoteSets){
    my $game = $1       if $noteSet =~ /\#STEPSTYPE    \s*:\s*   ($reName)   \s*;\s*/sxi;
    my $difficulty = $1 if $noteSet =~ /\#DIFFICULTY   \s*:\s*   ($reName)   \s*;\s*/sxi;
    my $smFeet = $1     if $noteSet =~ /\#METER        \s*:\s*   (\d+)       \s*;\s*/sxi;
    my $smRadar = $1    if $noteSet =~ /\#RADARVALUES  \s*:\s*   ([^;]+)     \s*;\s*/sxi;
    my $notes = $1      if $noteSet =~ /\#NOTES        \s*:\s*   ([^;]+)     \s*;\s*/sxi;
    my $bpms = $1       if $noteSet =~ /\#BPMS         \s*:\s*   ([^;]+)     \s*;\s*/sxi;
    my $stops = $1      if $noteSet =~ /\#STOPS        \s*:\s*   ([^;]+)     \s*;\s*/sxi;

    $smFeet = "" if not defined $smFeet;
    $smRadar = "" if not defined $smRadar;

    die "ERROR: missing STEPSTYPE from $smFile $noteSet\n" if not defined $game;
    die "ERROR: missing DIFFICULTY from $smFile\n" if not defined $difficulty;
    die "ERROR: missing NOTES from $smFile\n" if not defined $notes;

    push @noteSetInfos, {
      game    => $game,
      diff    => $difficulty,
      smFeet  => $smFeet,
      smRadar => $smRadar,
      notes   => $notes,
      bpms    => $bpms,
      stops   => $stops,
    };
  }

  my @playerNoteSetInfos;
  for my $noteSetInfo(@noteSetInfos){
    my $game = $$noteSetInfo{game};
    my $notes = $$noteSetInfo{notes};

    if($game =~ /^(dance-couple)$/i and $notes =~ /${SM_CHARS}{8}/){
      my $notesP1 = $notes;
      my $notesP2 = $notes;
      $notesP1 =~ s/(${SM_CHARS}{4})(${SM_CHARS}{4})/$1/g;
      $notesP2 =~ s/(${SM_CHARS}{4})(${SM_CHARS}{4})/$2/g;
      push @playerNoteSetInfos, {
        %$noteSetInfo,
        game => "$$noteSetInfo{game}-p1",
        notes => $notesP1,
      };
      push @playerNoteSetInfos, {
        %$noteSetInfo,
        game => "$$noteSetInfo{game}-p2",
        notes => $notesP2,
      };
    }elsif($game =~ /^(pump-couple)$/i and $notes =~ /${SM_CHARS}{10}/){
      my $notesP1 = $notes;
      my $notesP2 = $notes;
      $notesP1 =~ s/(${SM_CHARS}{5})(${SM_CHARS}{5})/$1/g;
      $notesP2 =~ s/(${SM_CHARS}{5})(${SM_CHARS}{5})/$2/g;
      push @playerNoteSetInfos, {
        %$noteSetInfo,
        game => "$$noteSetInfo{game}-p1",
        notes => $notesP1,
      };
      push @playerNoteSetInfos, {
        %$noteSetInfo,
        game => "$$noteSetInfo{game}-p2",
        notes => $notesP2,
      };
    }elsif($game =~ /^(dance-routine)$/i and $notes =~ /&/){
      my $notesP1 = $notes;
      my $notesP2 = $notes;
      $notesP1 =~ s/^(.*)&(.*)$/$1/s;
      $notesP2 =~ s/^(.*)&(.*)$/$2/s;
      push @playerNoteSetInfos, {
        %$noteSetInfo,
        game => "$$noteSetInfo{game}-p1",
        notes => $notesP1,
      };
      push @playerNoteSetInfos, {
        %$noteSetInfo,
        game => "$$noteSetInfo{game}-p2",
        notes => $notesP2,
      };
    }else{
      push @playerNoteSetInfos, $noteSetInfo;
    }
  }

  @noteSetInfos = @playerNoteSetInfos;

  #process/expand/format note-set data
  for my $noteSetInfo(@noteSetInfos){
    $$noteSetInfo{expandedNoteRows} = getExpandedNoteRows $$noteSetInfo{notes};
    $$noteSetInfo{bpmsByRow} = convertValuesByBeatToValuesByRow($$noteSetInfo{bpms});
    $$noteSetInfo{stopsByRow} = convertValuesByBeatToValuesByRow($$noteSetInfo{stops});
  }

  my %noteSetsByGame;
  for my $noteSetInfo(@noteSetInfos){
    my $game = $$noteSetInfo{game};
    $noteSetsByGame{$game} = [] if not defined $noteSetsByGame{$game};
    push @{$noteSetsByGame{$game}}, $noteSetInfo;
  }

  # generate a unique list of difficulties for each game
  #   first pass:  swap adjacent dupes to match (beginner, easy, medium, hard, expert)
  #   second pass: append an index to any remaining dupes
  my %uniqDiffsPerGame;
  for my $game(sort keys %noteSetsByGame){
    my @gameNoteSets = @{$noteSetsByGame{$game}};
    my @origDiffs = map {$$_{diff}} @gameNoteSets;
    my @uniqDiffs = getUniqueDifficulties(@origDiffs);
    $uniqDiffsPerGame{$game} = [@uniqDiffs];
    for(my $i=0; $i<@gameNoteSets; $i++){
      my $noteSetInfo = $gameNoteSets[$i];
      my $oldDiff = $$noteSetInfo{diff};
      my $uniqDiff = $uniqDiffs[$i];
      if($oldDiff ne $uniqDiff){
        print STDERR "WARNING: duplicate difficulty for $game: "
          ." $oldDiff (using $uniqDiff)\n";
        $$noteSetInfo{diff} = $uniqDiff;
      }
    }
  }

  #ensure unique game-diff-key for each note-set in the file
  for my $noteSetInfo(@noteSetInfos){
    my $game = $$noteSetInfo{game};
    my $diff = $$noteSetInfo{diff};

    my $gameDiffKey = generateGameDiffKey($game, $diff);

    if(defined $$smInfo{noteSetInfoByGameDiffKey}{$gameDiffKey}){
      die "ERROR: dupe game-diff-key not resolved\n";
    }

    $$smInfo{noteSetInfoByGameDiffKey}{$gameDiffKey} = $noteSetInfo;
    push @{$$smInfo{gameDiffKeyOrder}}, $gameDiffKey;
  }

  my $gameDiffKeyCount = @{$$smInfo{gameDiffKeyOrder}};
  if($gameDiffKeyCount == 0){
    die "ERROR: could not parse any note sets in $smFile\n";
  }

  return $smInfo;
}

sub getUniqueDifficulties(@){
  my @diffs = @_;
  @diffs = swapDupeDiffsForMissingAdjacentDiffs(@diffs);
  @diffs = incrementDupeDiffs(@diffs);
  return @diffs;
}

#fill in adjacent missing diffs, if any, in (beginner, easy, medium, hard, expert)
#  -only dupe diffs can change, and only if new diff is not a dupe
#  -if both are permitted, a swap to increase diff is preferred over a decrease
#    e.g.: (easy, hard, hard, expert)   => (easy, *MEDIUM*, hard, expert)
#          (medium, medium, medium)     => (*EASY*, medium, *HARD*)
#          (foo, bar, medium, medium)   => (foo, bar, medium, *HARD*)
#          (easy, medium, medium, hard) => (easy, medium, medium, hard)
#          (medium, medium, medium)     => (*EASY*, medium, *HARD*)
#          (medium, medium)             => (medium, *HARD*)
sub swapDupeDiffsForMissingAdjacentDiffs(@){
  my @diffs = @_;
  my @newDiffs = @diffs;

  my @canonicalDiffs = qw(beginner easy medium hard expert);

  my %prevCanonicalDiff;
  my %nextCanonicalDiff;
  for(my $i=0; $i<@canonicalDiffs; $i++){
    my $d=$canonicalDiffs[$i];
    $prevCanonicalDiff{$d} = $canonicalDiffs[$i-1] if $i-1 >= 0;
    $nextCanonicalDiff{$d} = $canonicalDiffs[$i+1] if $i+1 <= $#canonicalDiffs;
  }

  my %seenDiffs = map {$_ => 1} @diffs;
  for(my $i=$#newDiffs; $i>=1; $i--){
    my $cur = $newDiffs[$i];
    my $prev = $newDiffs[$i-1];

    #dupe found
    if($cur eq $prev){
      my $prevDiff = $prevCanonicalDiff{$cur};
      my $nextDiff = $nextCanonicalDiff{$cur};
      if(defined $nextDiff and not defined $seenDiffs{$nextDiff}){
        #increment the right-hand dupe
        $newDiffs[$i] = $nextDiff;
        $seenDiffs{$nextDiff} = 1;
      }elsif(defined $prevDiff and not defined $seenDiffs{$prevDiff}){
        #decrement the left-hand dupe
        $newDiffs[$i-1] = $prevDiff;
        $seenDiffs{$prevDiff} = 1;
      }
    }
  }

  return @newDiffs;
}

sub incrementDupeDiffs(@){
  my @diffs = @_;
  my @newDiffs = @diffs;

  for(my $i=$#newDiffs; $i>=0; $i--){
    my $d = $diffs[$i];
    my %otherDiffs = map {$newDiffs[$_] => 1} grep {$_ != $i} 0..$#newDiffs;

    while(defined $otherDiffs{$d}){
      my $index = 1;
      $index = $1 if $d =~ /(\d+)$/;
      $index++;
      $d =~ s/\d+$//;
      $d = "$d$index";
    }
    $newDiffs[$i] = $d;
  }

  return @newDiffs;
}

sub extractSongNameId($){
  my ($title) = @_;

  my $songNameId;
  if(isExecAvailable("zenius-ddrsonglist")){
    open CMD, "-|", "zenius-ddrsonglist", "--extract-name-id", $title;
    $songNameId = join '', <CMD>;
    close CMD;
    chomp $songNameId;
  }

  if(not defined $songNameId or $songNameId !~ /^[a-z0-9\-]+$/){
    $songNameId = lc $title;
    $songNameId =~ s/&/-and-/g;
    $songNameId =~ s/[^a-z0-9]/-/g;
    $songNameId =~ s/--+/-/;
    $songNameId =~ s/^-*//;
    $songNameId =~ s/-*$//;
  }

  return $songNameId;
}

#convert simfile atts like "#BPMS:" and "#STOPS:", which are by beat,
# to values like BPM_ROWS and STOP_ROWS, which are by row
sub convertValuesByBeatToValuesByRow($){
  my ($csvBeatValPairs) = @_;

  if(not defined $csvBeatValPairs){
    return undef;
  }

  my $valsByRow = {};
  my @beatValPairs = split /,/, $csvBeatValPairs;
  for my $beatValPair(@beatValPairs){
    $beatValPair =~ s/[ \t\r\n]*//g;
    next if $beatValPair eq "";

    my ($beat, $val);
    if($beatValPair =~ /^(\d+|\d*\.\d+)=(-?\d+|-?\d*\.\d+)$/){
      ($beat, $val) = ($1, $2);
    }else{
      if($beatValPair =~ /^-/){
        print STDERR "WARNING: skipping negative-beat for BEAT=VALUE entry"
          . "(this is a BPM/STOP before the song starts, sometimes used instead of #OFFSET\n";
        next;
      }else{
        die "ERROR: invalid BEAT=VALUE entry \"$beatValPair\"\n";
      }
    }
    my $fracRow = $beat * $ROWS_PER_BEAT;
    my $row = int($fracRow + 0.5);

    my $fracDiff = $fracRow - $row;
    $fracDiff = 0 - $fracDiff if $fracDiff < 0;
    if($fracDiff > 0.001){
      my $msg = "WARNING: invalid BEAT in BPM"
        . " (not close to 1/$ROWS_PER_MEASURE note; forced to the nearest anyway)"
        . " beat\"$beat\" => row\"$fracRow\" ~> row\"$row\""
        . "\n"
        ;
      print STDERR $msg;
    }

    $$valsByRow{$row} = $val;
  }
  return $valsByRow;
}

sub generateGameDiffKey($$){
  my ($game, $diff) = @_;
  return lc "$game-$diff";
}

sub isGameDiffSkipped($$){
  my ($gameDiffFilters, $gameDiffKey) = @_;

  my $gameFilterRegex = $$gameDiffFilters{gameFilterRegex};
  my $diffDDRFilterRegex = $$gameDiffFilters{diffDDRFilterRegex};
  my $diffSMFilterRegex = $$gameDiffFilters{diffSMFilterRegex};

  my ($game, $diff);
  if($gameDiffKey =~ /^(.+)-([^-]+)$/){
    ($game, $diff) = ($1, $2);
  }else{
    die "ERROR: invalid gameDiffKey $gameDiffKey\n";
  }

  if(defined $gameFilterRegex){
    my $game = $game;
    my $gameAbbrev = abbrevGame($game);
    if($game !~ /$gameFilterRegex/i and $gameAbbrev !~ /$gameFilterRegex/i){
      return 1;
    }
  }
  if(defined $diffDDRFilterRegex){
    my $diffDDR = formatDDRDiff($diff);
    my $diffDDRAbbrev = abbrevDiff($diff);
    if($diffDDR !~ /$diffDDRFilterRegex/i and $diffDDRAbbrev !~ /$diffDDRFilterRegex/i){
      return 1;
    }
  }
  if(defined $diffSMFilterRegex){
    my $diffSM = $diff;
    if($diffSM !~ /$diffSMFilterRegex/i){
      return 1;
    }
  }
  return 0;
}

#SM files contain a list of MEASUREs for each game-difficulty pair
#  each MEASURE is a list of 192 NOTE_ROWs (which is usually condensed as below),
#    one per line, with a comma separating MEASUREs on its own line
#
#  each NOTE_ROW contains one chracter per arrow
#    e.g.:  1100   for left-down jump
#
#  each MEASURE is also divided into 4 BEATs, which are 48 NOTE_ROWs each
#    (stepmania actively assumes 4/4 time signature for some reason,
#     instead of not having a time sig)
#
#  MEASUREs are condensed to only 4/8/12/16/24/32/48/64/192 rows where possible
#    (if a measure has only 1/32 notes, it will have 32 rows instead of 192)
#
#  this method expands it back up to 192 NOTE_ROWs per MEASURE,
#    by inserting all-zero blank rows,
#    and then joins all the rows together in a simple list, ignoring MEASURE
#
#  e.g.:
#    this measure:
#      1000
#      0100
#      0010
#      0001
#      ,
#    will expand from 4 to 192 rows, inserting 47 rows of '0000' after each of the 4 rows
#    the resulting rows will be all '0000's, except for:
#      row#0, row#48, row#96, and row#144
sub getExpandedNoteRows($){
  my ($noteSetText) = @_;

  #remove empty last measure(s)
  $noteSetText =~ s/,\s*$//;
  #remove comments
  $noteSetText =~ s/\/\/.*(\n|$)/$1/g;

  my @measures = split /,/, $noteSetText;

  my @noteRows;
  for my $measure(@measures){
    my @lines = split /[\r\n]+/, $measure;

    s/F/0/g foreach @lines;               #remove fakes
    @lines = grep {$_ !~ /^\s*$/} @lines; #remove whitespace-only/empty lines

    for my $line(@lines){
      $line =~ s/^\s*//;
      $line =~ s/\s*$//;
      if($line !~ /^${SM_CHARS}+$/){
        die "ERROR: malformed measure row $line\n";
      }
    }

    my @collapsedMeasureRows = @lines;
    my $collapsedMeasureRowCount = @collapsedMeasureRows;

    die "ERROR: empty measure $measure\n" if $collapsedMeasureRowCount == 0;

    my $firstRow = $collapsedMeasureRows[0];
    my $emptyRow = $firstRow;
    $emptyRow =~ s/${SM_CHARS}/0/g;
    if($emptyRow !~ /^0+$/){
      die "ERROR: malformed first measure row $firstRow\n";
    }

    my $repeatRowCount = int($ROWS_PER_MEASURE/$collapsedMeasureRowCount);

    my @expandedMeasureRows;
    for my $row(@collapsedMeasureRows){
      if($row !~ /^${SM_CHARS}+$/){
        die "ERROR: malformed note row: $row\n";
      }
      push @expandedMeasureRows, $row;
      for(my $i=0; $i<$repeatRowCount-1; $i++){
        push @expandedMeasureRows, $emptyRow;
      }
    }

    if(@expandedMeasureRows != $ROWS_PER_MEASURE){
      die "ERROR: malformed measure (rowCount=$collapsedMeasureRowCount):\n$measure";
    }
    @noteRows = (@noteRows, @expandedMeasureRows);
  }

  return \@noteRows;
}

sub getCacheDir($){
  my ($file) = @_;
  my $checksum = isExecAvailable("sha256sum") ? getChecksumFile($file) : "nochecksum";
  my $fileName = $file;
  $fileName =~ s/^.*\///;
  $fileName = lc $fileName;
  $fileName =~ s/\.([a-z0-9]+)$//;
  $fileName =~ s/[^a-z0-9]/-/g;
  $fileName =~ s/--+/-/g;
  $fileName =~ s/^-*//g;
  $fileName =~ s/-*$//g;

  if($fileName eq ""){
    $fileName = abs_path(dirname($file));
    $fileName =~ s/^.*\///;
    $fileName = lc $fileName;
    $fileName =~ s/\.([a-z0-9]+)$//;
    $fileName =~ s/[^a-z0-9]/-/g;
    $fileName =~ s/--+/-/g;
    $fileName =~ s/^-*//g;
    $fileName =~ s/-*$//g;
  }

  if($fileName eq ""){
    $fileName = "unknown";
  }

  my $baseDir = defined $ENV{HOME} ? $ENV{HOME} : ".";

  my $cacheDir = "$baseDir/$CACHE_BASE_DIR_SUFFIX";

  return "$cacheDir/$fileName-$checksum";
}

sub abbrevGame($){
  my ($game) = @_;

  if(defined $GAME_ABBREVS{$game}){
    $game = $GAME_ABBREVS{$game};
  }elsif($game =~ /^([^-]*)-([^-]*)$/){
    my ($left, $right) = ($1, $2);
    while(length "$left$right" > 7){
      if(length $right > 4 or (length $left <= 1)){
        $right = removeMiddleChar($right);
      }else{
        $left = removeMiddleChar($left);
      }
    }
    $game = "$left$right";
  }elsif($game =~ /^([^-]*)-([^-]*)-([^-]*)$/){
    my ($left, $middle, $right) = ($1, $2, $3);
    while(length "$left$middle$right" > 7){
      if(length $right > 2 or (length $left <= 1 and length $middle <= 1)){
        $right = removeMiddleChar($right);
      }elsif(length $middle > 4 or (length $left <= 1)){
        $middle = removeMiddleChar($middle);
      }else{
        $left = removeMiddleChar($left);
      }
    }
    $game = "$left$middle$right";
  }

  $game = substr $game, 0, 7;
  return $game . ("_" x (7 - length $game));
}

sub abbrevDiff($){
  my ($diff) = @_;

  if(defined $DIFF_ABBREVS{$diff}){
    $diff = $DIFF_ABBREVS{$diff};
  }

  $diff = substr $diff, 0, 5;
  return $diff . ("_" x (5 - length $diff));
}

#ab => a, abc => ac, abcd => abd, abcde => abde, abcdef => abcef
sub removeMiddleChar($){
  my ($str) = @_;
  return "" if length $str == 0;

  my $len = length $str;
  my $target = int($len/2);

  $target = 0 if $target < 0;
  $target = $len - 1 if $target >= $len;

  return substr($str, 0, $target) . substr($str, $target+1, $len-$target-1);
}

sub formatTimeMSS($){
  my ($time) = @_;
  my $m = int($time/60.0);
  my $s = $time - $m*60;
  return sprintf "%d:%02d", $m, $s;
}

sub boingCompressString($){
  my ($str) = @_;
  my @operations = qw(GZIP BASE64 BOING);

  if(not isExecAvailable("gzip") or not isExecAvailable("base64")){
    return $str;
  }

  my $data = $str;
  for my $operation(@operations){
    if($operation =~ /^(GZIP)$/i){
      $data = pipeCmdData("gzip -f", $data);
    }elsif($operation =~ /^(BASE64)$/i){
      $data = pipeCmdData("base64 -w 0", $data);
    }elsif($operation =~ /^(BOING)$/i){
      $data =~ s/&/&amp;/g;
      $data =~ s/\n/&nl;/g;
      $data =~ s/\r/&cr;/g;
      $data =~ s/%/&boing;/g;
    }else{
      die "ERROR: unknown compress-string operation $operation\n";
    }
  }

  $data = "%" . join("", map{"$_%"} @operations) . $data . "%";

  return $data;
}

#e.g.: %BOING%abc&boing;def%   =>  abc%def
sub boingDecompressString($){
  my ($str) = @_;
  if($str !~ /^%((?:GZIP%|BASE64%|BOING%)+)([^%]+)%$/i){
    #not a boingCompressString() string
    return $str;
  }
  my ($operationsStr, $data) = ($1, $2);
  my @operations = split /%/, $operationsStr;
  @operations = reverse @operations; #apply operation closest to the data first

  for my $operation(@operations){
    if($operation =~ /^(GZIP)$/i){
      $data = pipeCmdData("gzip -f --decompress", $data);
    }elsif($operation =~ /^(BASE64)$/i){
      $data = pipeCmdData("base64 -w 0 --decode", $data);
    }elsif($operation =~ /^(BOING)$/i){
      $data =~ s/&boing;/%/g;
      $data =~ s/&cr;/\r/g;
      $data =~ s/&nl;/\n/g;
      $data =~ s/&amp;/&/g;
    }else{
      die "ERROR: unknown compress-string operation $operation\n";
    }
  }

  return $data;
}

sub pipeCmdData($$){
  my ($cmd, $data) = @_;

  open2(my $OUT, my $IN, $cmd);
  print $IN $data;
  close $IN;
  $data = join '', <$OUT>;
  close $OUT;

  return $data;
}

sub readFile($){
  my ($file) = @_;
  open FH, "< $file" or die "ERROR: could not read $file\n";
  my $contents = join '', <FH>;
  close FH;
  return $contents;
}

sub getChecksumStr($){
  my ($str) = @_;
  my $checksum = pipeCmdData("sha256sum", $str);
  if($checksum =~ /^([0-9a-f]{64})(?:\s.*)$/){
    return $1;
  }else{
    die "ERROR: sha256sum failed\n";
  }
}

sub getChecksumFile($){
  my ($file) = @_;
  open CMD, "-|", "sha256sum", $file or die "ERROR: sha256sum failed for $file\n$!\n";
  my $checksum = <CMD>;
  close CMD;
  if($checksum =~ /^([0-9a-f]{64})(?:\s.*)$/){
    return $1;
  }else{
    die "ERROR: sha256sum failed for $file\n";
  }
}

sub isExecAvailable($){
  my ($exec) = @_;
  return 0 if $^O =~ /win/i;
  system "type \"$exec\" >/dev/null 2>/dev/null";
  return $? == 0 ? 1 : 0;
}

&main(@ARGV);
