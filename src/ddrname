#!/usr/bin/perl
use strict;
use warnings;

my $scoreDir = "$ENV{HOME}/Desktop/DCIM/xddr";

my @songArgs = qw(
  321stars
  arrabbiata
  astupidbarber
  blindjustice
  chaos
  doll
  dropout
  dynamiteraveairspecial
  exoticethnic
  flowers
  healingdvision
  healingvisionangelic
  legendofmax
  max300
  max300smmm
  max300xspecial
  maxxunlimited
  mugen
  mysummerlove
  no13
  orioneuro
  paranoiaeternalstm200
  paranoiaevolution200
  paranoiarespect
  paranoiasurvivor270
  sanamollete
  xepher
);
my $okSongArgs = join '|', @songArgs;

my @gameArgs = qw(doubles);
my $okGameArgs = join '|', @gameArgs;

my @difficultyArgs = qw(beginner basic difficult expert challenge);
my $okDifficultyArgs = join '|', @difficultyArgs;

my @roundArgs = qw(1st 2nd 3rd);
my $okRoundArgs = join '|', @roundArgs;

my @barArgs = qw(bar nobar);
my $okBarArgs = join '|', @barArgs;

my @extraArgs = qw(fc pfc);
my $okExtraArgs = join '|', @extraArgs;

my $usage = "Usage:
  $0 JPG_FILE [ARG ARG ..]

  rename a jpeg file using a consistent format
  \"########_###_SONG_GAME_DIFFICULTY_SCORE_EXTRA_BAR_ROUND.jpg\"
  ######## is presumably a date in YYYYMMDD and ### is the camera pic index

     JPG_FILE
       jpeg file to rename
       must start with '########_###' and end with '.jpg'

     ARG
       one of [SONG|GAME|DIFFICULTY|SCORE|ROUND|BAR|EXTRA]
       exactly one SONG, DIFFICULTY, SCORE, ROUND, and BAR must be given
       exactly zero or one GAME args can be given
       exactly zero or one EXTRA args can be given

     SONG
       one of [$okSongArgs]

     GAME
       one of [$okGameArgs]

     DIFFICULTY
       one of [$okDifficultyArgs]

     SCORE
       an integer between 100,000 and 1,000,000
       must be a multiple of 10
       commas, if present, are stripped out

     EXTRA
       one of [$okExtraArgs]

     BAR
       one of [$okBarArgs]

     ROUND
       one of [$okRoundArgs]

  $0 --bash-complete COMP_LINE COMP_POINT
     print a list of words for bash completion
     COMP_LINE  - the full cmdline as a string
     COMP_POINT - the cursor position in the cmdline
";

sub parseArgs(@);
sub getScoreFiles();
sub parseScoreFiles(@);
sub getScoreBuckets($@);
sub bashComplete($$);

sub main(@){
  if(@_ == 3 and $_[0] =~ /^--bash-complete$/ and $_[2] =~ /^\d+$/){
    print join ' ', bashComplete($_[1], $_[2]);
    exit 0;
  }

  my $file = shift;
  my $info = parseArgs @_;
  die $usage if not defined $file or not -f $file or not defined $info;
  die "missing SONG\n" if not defined $$info{song};
  die "missing DIFFICULTY\n" if not defined $$info{difficulty};
  die "missing SCORE\n" if not defined $$info{score};
  die "missing BAR\n" if not defined $$info{bar};
  die "missing ROUND\n" if not defined $$info{round};

  $file =~ s/^\.\///;

  if($file !~ /^(\d{8}_\d{3}).*\.jpg$/){
    die "misnamed jpg file: $file\n";
  }
  my $prefix = $1;

  my $newFileName = '';
  $newFileName .= "$prefix";
  $newFileName .= "_$$info{song}";
  $newFileName .= "_$$info{game}" if defined $$info{game};
  $newFileName .= "_$$info{difficulty}";
  $newFileName .= "_$$info{score}";
  $newFileName .= "_$$info{extra}" if defined $$info{extra};
  $newFileName .= "_$$info{bar}";
  $newFileName .= "_$$info{round}";
  $newFileName .= ".jpg";

  my @cmd = ("mv", $file, $newFileName);
  print "@cmd\n";
  system @cmd;
}

sub parseArgs(@){
  my $info = {};
  for my $arg(@_){
    if($arg =~ /^($okSongArgs)$/){
      return undef if defined $$info{song};
      $$info{song} = $arg;
    }elsif($arg =~ /^($okGameArgs)$/){
      return undef if defined $$info{game};
      $$info{game} = $arg;
    }elsif($arg =~ /^($okDifficultyArgs)$/){
      return undef if defined $$info{difficulty};
      $$info{difficulty} = $arg;
    }elsif($arg =~ /^(\d,?){5,6}0$/){
      my $score = $arg;
      $score =~ s/,//g;
      $score = int($score);
      return undef if defined $$info{score} or $score > 1000000;
      $$info{score} = $score;
    }elsif($arg =~ /^($okExtraArgs)$/){
      return undef if defined $$info{extra};
      $$info{extra} = $arg;
    }elsif($arg =~ /^($okBarArgs)$/){
      return undef if defined $$info{bar};
      $$info{bar} = $arg;
    }elsif($arg =~ /^($okRoundArgs)$/){
      return undef if defined $$info{round};
      $$info{round} = $arg;
    }else{
      return undef;
    }
  }
  return $info;
}

sub getScoreFiles(){
  my @files = `cd $scoreDir && ls *.jpg`;
  chomp foreach @files;
  @files = grep {$_ =~ /^\d+_.*\.jpg$/ and $_ !~ /_reminder_/} @files;
  return @files;
}

sub parseScoreFiles(@){
  my @files = @_;
  my $scores = {};
  for my $file(@files){
    if($file !~ /^
      (\d{8})
      _(\d+)
      _($okSongArgs)
      (?:_($okGameArgs))?
      _($okDifficultyArgs)
      _(\d+)
      (?:_($okExtraArgs))?
      _($okBarArgs)
      _($okRoundArgs)
      \.jpg$/x){
      die "malformed file name: $file\n";
    }
    $$scores{$file} = {
      file       => $file,
      date       => $1,
      index      => $2,
      song       => $3,
      game       => $4,
      difficulty => $5,
      score      => $6,
      extra      => $7,
      bar        => $8,
      round      => $9,
    };
  }
  return $scores;
}

sub getScoreBuckets($@){
  my ($scores, @bucketFields) = @_;
  my $buckets = {};
  for my $file(keys %$scores){
    my $score = $$scores{$file};
    my @bucketFieldVals = map {$$score{$_}} @bucketFields;

    my $bucketName = join "-", grep {defined $_} @bucketFieldVals;
    $$buckets{$bucketName} = [] if not defined $$buckets{$bucketName};
    push @{$$buckets{$bucketName}}, $score;
  }
  return $buckets;
}

sub bashComplete($$){
  my ($cmdLine, $pos) = @_;
  my $cmd = substr $cmdLine, 0, $pos;
  my $isNewWord = $cmd =~ /\s$/;
  $cmd =~ s/^\s+//;
  $cmd =~ s/\s+$//;

  my @words = split /\s+/, $cmd;
  shift @words;
  pop @words if not $isNewWord;

  if(@words == 0){
    my @jpgFiles = `ls *.jpg 2>/dev/null`;
    chomp foreach @jpgFiles;
    return @jpgFiles;
  }
  shift @words;

  my $info = parseArgs @words;
  if(not defined $info){
    return ();
  }

  my @complete;
  @complete = (@songArgs, @complete) if not defined $$info{song};
  #@complete = (@gameArgs, @complete) if not defined $$info{game};
  @complete = (@difficultyArgs, @complete) if not defined $$info{difficulty};
  #@complete = (@extraArgs, @complete) if not defined $$info{extra};
  @complete = (@barArgs, @complete) if not defined $$info{bar};
  @complete = (@roundArgs, @complete) if not defined $$info{round};

  return @complete;
}

&main(@ARGV);
