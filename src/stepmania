#!/usr/bin/perl
use strict;
use warnings;

my $exec = "$ENV{HOME}/Desktop/Games/stepmania/latest/stepmania";
my $confDir = "$ENV{HOME}/.stepmania-5.0";

my $saveDir = "$confDir/Save";
my $themesDir = "$confDir/Themes";
my $fallbackThemeDir = "$themesDir/_fallback";
my $machineProfileDir = "$confDir/Save/MachineProfile";
my $themeName = "teleshoes";

my $speedMods = "0.5x,1x,1.5x,2x,2.5x,3x,C300,C350,C400,m550";
my $defaultScreen = 'ScreenSelectMusic';

my $metricsPrefs = {
  'Global' => {'FallbackTheme' => "$themeName-base"},
  'Common' => {'DefaultModifiers' => '"C350, midi-note, Overhead"'},
};

my $prefs = {
  'Options' => {
    GlobalOffsetSeconds       => "-0.056623",
    AutoMapOnJoyChange        => 0,
    OnlyDedicatedMenuButtons  => 1,
    Center1Player             => 1,
    EventMode                 => 1,
    BGBrightness              => '0.600000',
    ShowSongOptions           => 'Ask',
    ShowCaution               => 0,
    ShowInstructions          => 0,
    ShowNativeLanguage        => 0,

    Windowed                  => 1,
    DisplayWidth              => 640,
    DisplayHeight             => 480,
    DisplayAspectRatio        => 1.3333,
    RefreshRate               => 60,

    DisplayColorDepth         => 16,
    MaxTextureResolution      => 1024,

    LastSeenVideoDriver       => 'OpenGL',
    VideoRenderers            => 'opengl',
  },
  'Game-dance' => {
    Announcer                 => '', #MAX2
    Theme                     => $themeName,
  },
};
my $themePrefs = {
  'StepMania 5 Default' => {
    'GameplayShowScore' => 'true',
  }
};

my $keyArgs = {
  joy1Name  => "ems",
  joy2Name  => "redoctane",
  joy1Index => 3,
  joy2Index => 4,
  kb1Name   => "kb1",
  kb2Name   => "kb2",
};

my $jsKeyGrid = {
            ##  UP DN LT RT  MU MD ML MR  BK ST
  redoctane => "03 02 01 04  05 06 07 08  10 09",
  ems       => "13 15 16 14  01 04 03 02  09 10",
  energy    => "01 02 03 04  05 06 07 08  09 10",
};
my $kbKeyGrid = {
            ##  UP/DN/LT/RT  MU/MD/ML/MR           BK/ST
  kb1       => "j f d k      up down left right    escape enter",
  kb2       => "u r e i      home end delete pgdn  x z",
};
my $keyGrid = {%$jsKeyGrid, %$kbKeyGrid};
my @jsNames = keys %$jsKeyGrid;

sub setMachineSpeedMods($);
sub setScriptSpeedMods($);
sub generateKeymap($$);
sub commentLine($$);
sub replaceLine($$$);
sub readLines($);
sub writeLines($@);
sub readConf($);
sub writeConf($);
sub modifyConf($$);
sub replaceConf($$);

my $usage = "Usage:
  $0 -h|--help
    Print this message
  $0 [OPTS]
    Launch stepmania after setting up preferences
  $0 <JOYNAME> <JS#> [<OPTS>]
    shorthand for:
      --js1Name=<JSNAME> --js1=<JS#> <OPTS>
  $0 <JOYNAME> <JS#> <JOYNAME> <JS#> [<OPTS>]
    shorthand for:
      --js1Name=<JSNAME> --js1=<JS#> --js2Name=<JSNAME> --js2=<JS#> <OPTS>
  OPTS:
   --js1Name=JOYNAME p1 joystick name {default=$$keyArgs{joy1Name}}
   --js2Name=JOYNAME p2 joystick name {default=$$keyArgs{joy2Name}}
   --js1=JS#         p1 joystick index {default=$$keyArgs{joy1Index}}
   --js2=JS#         p2 joystick index {default=$$keyArgs{joy2Index}}
   -w                set Windowed to 1, overriding config
   -f                set Windowed to 0, overriding config
   --screen=SCREEN   jump to screen SCREEN {default=$defaultScreen}
   -i                synonynm for --screen=ScreenTestInput

  JOYNAME: user-defined joystick name, one of:
           [@jsNames]
  SCREEN:  screen class name
  JS#:     integer for internal stepmania joystick index
";

my $prefsIni = "$saveDir/Preferences.ini";
my $themePrefsIni = "$saveDir/ThemePrefs.ini";
my $keymapsIni = "$saveDir/Keymaps.ini";
my $themeMetricsIni = "$themesDir/$themeName/metrics.ini";
my $machineSpeedModsFile = "$machineProfileDir/SpeedMods.txt";
my $scriptSpeedModsFile = "$fallbackThemeDir/Scripts/03 CustomSpeedMods.lua";
my $fallbackMetricsIni = "$fallbackThemeDir/metrics.ini";
my $screenMapOverlay = "BGAnimations/ScreenMapControllers overlay.lua";
my $fallbackScreenMapOverlay = "$fallbackThemeDir/$screenMapOverlay";

sub main(@){
  die $usage if @_ == 1 and $_[0] =~ /^(-h|--help)$/;

  if(@_ >= 2 and defined $$jsKeyGrid{$_[0]} and $_[1] =~ /^\d+$/){
    $$keyArgs{joy1Name} = shift;
    $$keyArgs{joy1Index} = shift;
  }
  if(@_ >= 2 and defined $$jsKeyGrid{$_[0]} and $_[1] =~ /^\d+$/){
    $$keyArgs{joy2Name} = shift;
    $$keyArgs{joy2Index} = shift;
  }

  $$prefs{Options}{TestInitialScreen} = $defaultScreen;
  for(my $i=0; $i<@_; $i++){
    if($_[$i] =~ /--js1Name=(.+)/ and defined $$jsKeyGrid{$1}){
      $$keyArgs{joy1Name} = $1;
    }elsif($_[$i] =~ /--js2Name=(.+)/ and defined $$jsKeyGrid{$1}){
      $$keyArgs{joy1Index} = $1;
    }elsif($_[$i] =~ /--js1=(\d+)/){
      $$keyArgs{joy2Name} = $1;
    }elsif($_[$i] =~ /--js2=(\d+)/){
      $$keyArgs{joy2Index} = $1;
    }elsif($_[$i] eq '-w'){
      $$prefs{Options}{Windowed} = 1;
    }elsif($_[$i] eq '-f'){
      $$prefs{Options}{Windowed} = 0;
    }elsif($_[$i] =~ /--screen=(.+)/){
      $$prefs{Options}{TestInitialScreen} = $1;
    }elsif($_[$i] eq '-i'){
      $$prefs{Options}{TestInitialScreen} = 'ScreenTestInput';
    }else{
      die $usage;
    }
  }

  commentLine $fallbackMetricsIni, "KeyConfigRequestStall";
  replaceLine $fallbackScreenMapOverlay,
    "local waitTime" => "local waitTime = 0";

  system "mkdir", "-p", "$saveDir";
  replaceConf $prefsIni, $prefs;
  replaceConf $themePrefsIni, $themePrefs;
  replaceConf $keymapsIni, generateKeymap($keyGrid, $keyArgs);
  replaceConf $themeMetricsIni, $metricsPrefs;
  #setMachineSpeedMods $speedMods;
  setScriptSpeedMods $speedMods;
  system $exec, [];
}

sub setScriptSpeedMods($){
  my $newSpeeds = shift;
  my @lines = readLines $scriptSpeedModsFile;

  my $ok = 0;
  my $oldSpeeds;
  my $linePrefixRe = '\s*local\s+DefaultMods\s*=\s*StringToModTable\s*\(\s*"';
  my $lineSuffixRe = '"\s*\)\s*';
  for my $line(@lines){
    if($line =~ s/^($linePrefixRe)(.*)($lineSuffixRe)$/$1$newSpeeds$3/){
      $oldSpeeds = $2;
      $ok = 1;
      last;
    }
  }
  die "Couldnt find speedmods line\n" if not $ok;
  print "Speeds: $oldSpeeds => $newSpeeds\n" if $oldSpeeds ne $newSpeeds;

  writeLines $scriptSpeedModsFile, @lines;
}
sub setMachineSpeedMods($){
  my $newSpeeds = shift;
  system "mkdir", "-p", $machineProfileDir;
  open FH, "> $machineSpeedModsFile"
    or die "Couldn't write $machineSpeedModsFile\n";
  print FH "$newSpeeds\n";
  close FH;
}

sub generateKeymap($$){
  my ($keyGrid, $keyArgs) = @_;

  my @buttonOrder = qw(
   Up Down Left Right
   MenuUp MenuDown MenuLeft MenuRight
   Back Start
  );

  my $keys = {};
  for my $name(keys %$keyGrid){
    my @btns = split /\s+/, $$keyGrid{$name};
    die "error parsing keyGrid for $name\n" if @btns != @buttonOrder;
    $$keys{$name} = {};
    for(my $i=0; $i<@buttonOrder; $i++){
      $$keys{$name}{$buttonOrder[$i]} = $btns[$i];
    }
  }

  my %keymap;
  for my $player((1, 2)){
    my $joyName = $player == 1 ? $$keyArgs{joy1Name} : $$keyArgs{joy2Name};
    my $joyIndex = $player == 1 ? $$keyArgs{joy1Index} : $$keyArgs{joy2Index};
    my $kbName = $player == 1 ? $$keyArgs{kb1Name} : $$keyArgs{kb2Name};
    die "Unknown joy config: $joyName\n" if not defined $$keys{$joyName};
    die "Unknown kb config: $kbName\n" if not defined $$keys{$kbName};

    for my $btn(@buttonOrder){
      my $joyBtn = $$keys{$joyName}{$btn};
      die "Non-integer joy button\n" if $joyBtn !~ /^\d+$/;
      $joyBtn = int($joyBtn);
      $joyBtn = undef if $joyBtn == 0;

      my $kbBtn = $$keys{$kbName}{$btn};

      my $val = '';
      $val .= "Joy${joyIndex}_B$joyBtn" if defined $joyBtn;
      $val .= ":" if defined $joyBtn and $kbBtn;
      $val .= "Key_$kbBtn" if defined $kbBtn;
      $keymap{"${player}_$btn"} = $val if length($val) > 0;
    }
  }
  return {'dance' => \%keymap};
}

sub commentLine($$){
  my ($file, $regex) = @_;
  my @lines = readLines $file;
  my $ok = 0;
  for my $line(@lines){
    if($line =~ /$regex/){
      $line =~ s/^#*/#/;
      $ok = 1;
    }
  }
  die "Could not find line in $file: $regex\n" if not $ok;
  writeLines $file, @lines;
}

sub replaceLine($$$){
  my ($file, $regex, $newLine) = @_;
  my @lines = readLines $file;
  my $ok = 0;
  for my $line(@lines){
    if($line =~ /$regex/){
      $line = $newLine;
      chomp $line;
      $line .= "\n";
      $ok = 1;
    }
  }
  die "Could not find line in $file: $regex\n" if not $ok;
  writeLines $file, @lines;
}

sub readLines($){
  my $file = shift;
  open FH, "< $file" or die "Could not read $file\n";
  my @lines = <FH>;
  close FH;
  return @lines;
}

sub writeLines($@){
  my ($file, @lines) = @_;
  open FH, "> $file" or die "Could not write $file\n";
  print FH @lines;
  close FH;
}

sub readConf($){
  my $s = shift();
  my $conf = {};
  my $confSection;
  for my $line(split /[\n\r]+/, $s){
    if($line =~ /^\[(.*)\]$/){
      $confSection = {};
      ${$conf}{$1} = $confSection;
    }elsif($line =~ /^(.*)=(.*)$/){
      $$confSection{$1} = $2;
    }
  }
  return $conf;
}

sub writeConf($){
  my %conf = %{shift()};
  my $s = '';
  for my $section(sort keys %conf){
    $s .= "[$section]\n";
    my $sectionConf = $conf{$section};
    for my $key(sort keys %$sectionConf){
      $s .= "$key=${$sectionConf}{$key}\n";
    }
    $s .= "\n";
  }
  return $s;
}

sub modifyConf($$){
  my %orig = %{shift()};
  my %changes = %{shift()};
  for my $section(keys %changes){
    if(not defined $orig{$section}){
      $orig{$section} = $changes{$section};
    }else{
      my $origSectionConf = $orig{$section};
      my $changesSectionConf = $changes{$section};
      for my $key(keys %$changesSectionConf){
        ${$origSectionConf}{$key} = ${$changesSectionConf}{$key};
      }
    }
  }
  return \%orig;
}

sub replaceConf($$){
  my $file = shift;
  my $changes = shift;
  $file =~ s/"/\\"/g;
  my $conf = readConf `cat "$file"`;
  my $content = writeConf(modifyConf($conf, $changes));
  open FH, "> $file" or die "Couldnt open $file for writing.\n";
  print FH $content;
  close FH;
}

main(@ARGV);
